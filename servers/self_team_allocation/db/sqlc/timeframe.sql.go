// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: timeframe.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getTimeframe = `-- name: GetTimeframe :one
SELECT starttime, endtime
FROM timeframe
WHERE course_phase_id = $1
`

type GetTimeframeRow struct {
	Starttime pgtype.Timestamp `json:"starttime"`
	Endtime   pgtype.Timestamp `json:"endtime"`
}

// Returns the start and end time for a given course phase.
func (q *Queries) GetTimeframe(ctx context.Context, coursePhaseID uuid.UUID) (GetTimeframeRow, error) {
	row := q.db.QueryRow(ctx, getTimeframe, coursePhaseID)
	var i GetTimeframeRow
	err := row.Scan(&i.Starttime, &i.Endtime)
	return i, err
}

const setTimeframe = `-- name: SetTimeframe :exec
INSERT INTO timeframe (course_phase_id, starttime, endtime)
VALUES ($1, $2, $3)
ON CONFLICT (course_phase_id)
DO UPDATE SET starttime = EXCLUDED.starttime,
               endtime = EXCLUDED.endtime
`

type SetTimeframeParams struct {
	CoursePhaseID uuid.UUID        `json:"course_phase_id"`
	Starttime     pgtype.Timestamp `json:"starttime"`
	Endtime       pgtype.Timestamp `json:"endtime"`
}

// Upsert the start and end time for a given course phase.
func (q *Queries) SetTimeframe(ctx context.Context, arg SetTimeframeParams) error {
	_, err := q.db.Exec(ctx, setTimeframe, arg.CoursePhaseID, arg.Starttime, arg.Endtime)
	return err
}
