// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: seat.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createSeatPlan = `-- name: CreateSeatPlan :exec
INSERT INTO seat (course_phase_id, seat_name)
SELECT $1, s
FROM unnest($2::text[]) AS s
`

type CreateSeatPlanParams struct {
	CoursePhaseID uuid.UUID `json:"course_phase_id"`
	Seats         []string  `json:"seats"`
}

func (q *Queries) CreateSeatPlan(ctx context.Context, arg CreateSeatPlanParams) error {
	_, err := q.db.Exec(ctx, createSeatPlan, arg.CoursePhaseID, arg.Seats)
	return err
}

const deleteSeatPlan = `-- name: DeleteSeatPlan :exec
DELETE FROM seat
WHERE course_phase_id = $1
`

func (q *Queries) DeleteSeatPlan(ctx context.Context, coursePhaseID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSeatPlan, coursePhaseID)
	return err
}

const getOwnSeatAssignment = `-- name: GetOwnSeatAssignment :one
SELECT s.seat_name, s.has_mac, s.device_id, s.assigned_student, t.first_name as tutor_first_name, t.last_name as tutor_last_name, t.email as tutor_email
FROM seat s
JOIN tutor t ON s.course_phase_id = t.course_phase_id AND s.assigned_tutor = t.id
WHERE s.course_phase_id = $1
  AND s.assigned_student = $2
`

type GetOwnSeatAssignmentParams struct {
	CoursePhaseID   uuid.UUID   `json:"course_phase_id"`
	AssignedStudent pgtype.UUID `json:"assigned_student"`
}

type GetOwnSeatAssignmentRow struct {
	SeatName        string      `json:"seat_name"`
	HasMac          bool        `json:"has_mac"`
	DeviceID        pgtype.Text `json:"device_id"`
	AssignedStudent pgtype.UUID `json:"assigned_student"`
	TutorFirstName  string      `json:"tutor_first_name"`
	TutorLastName   string      `json:"tutor_last_name"`
	TutorEmail      string      `json:"tutor_email"`
}

func (q *Queries) GetOwnSeatAssignment(ctx context.Context, arg GetOwnSeatAssignmentParams) (GetOwnSeatAssignmentRow, error) {
	row := q.db.QueryRow(ctx, getOwnSeatAssignment, arg.CoursePhaseID, arg.AssignedStudent)
	var i GetOwnSeatAssignmentRow
	err := row.Scan(
		&i.SeatName,
		&i.HasMac,
		&i.DeviceID,
		&i.AssignedStudent,
		&i.TutorFirstName,
		&i.TutorLastName,
		&i.TutorEmail,
	)
	return i, err
}

const getSeatPlan = `-- name: GetSeatPlan :many
SELECT course_phase_id, seat_name, has_mac, device_id, assigned_student, assigned_tutor
FROM seat
WHERE course_phase_id = $1
ORDER BY seat_name
`

func (q *Queries) GetSeatPlan(ctx context.Context, coursePhaseID uuid.UUID) ([]Seat, error) {
	rows, err := q.db.Query(ctx, getSeatPlan, coursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Seat
	for rows.Next() {
		var i Seat
		if err := rows.Scan(
			&i.CoursePhaseID,
			&i.SeatName,
			&i.HasMac,
			&i.DeviceID,
			&i.AssignedStudent,
			&i.AssignedTutor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSeat = `-- name: UpdateSeat :exec
UPDATE seat
SET has_mac = $3,
    device_id = $4,
    assigned_student = $5,
    assigned_tutor = $6
WHERE course_phase_id = $1
  AND seat_name = $2
`

type UpdateSeatParams struct {
	CoursePhaseID   uuid.UUID   `json:"course_phase_id"`
	SeatName        string      `json:"seat_name"`
	HasMac          bool        `json:"has_mac"`
	DeviceID        pgtype.Text `json:"device_id"`
	AssignedStudent pgtype.UUID `json:"assigned_student"`
	AssignedTutor   pgtype.UUID `json:"assigned_tutor"`
}

func (q *Queries) UpdateSeat(ctx context.Context, arg UpdateSeatParams) error {
	_, err := q.db.Exec(ctx, updateSeat,
		arg.CoursePhaseID,
		arg.SeatName,
		arg.HasMac,
		arg.DeviceID,
		arg.AssignedStudent,
		arg.AssignedTutor,
	)
	return err
}
