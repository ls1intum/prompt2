// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: course_phase_participation.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createOrUpdateCoursePhaseParticipation = `-- name: CreateOrUpdateCoursePhaseParticipation :one
INSERT INTO course_phase_participation
    (course_phase_id, course_participation_id, pass_status, restricted_data, student_readable_data)
SELECT
    $1 AS course_phase_id,
    $2 AS course_participation_id,
    COALESCE($3, 'not_assessed') AS pass_status,
    $4 AS restricted_data,
    $5 AS student_readable_data
FROM course_participation cp
JOIN course_phase cph ON cp.course_id = cph.course_id
WHERE cp.id = $2
  AND cph.id = $3
ON CONFLICT (course_phase_id, course_participation_id)
DO UPDATE SET
  pass_status = COALESCE($3, course_phase_participation.pass_status),
  restricted_data = course_phase_participation.restricted_data || $4,
  student_readable_data = course_phase_participation.student_readable_data || $5
RETURNING course_participation_id, course_phase_id, restricted_data, pass_status, last_modified, student_readable_data
`

type CreateOrUpdateCoursePhaseParticipationParams struct {
	CoursePhaseID         uuid.UUID      `json:"course_phase_id"`
	CourseParticipationID uuid.UUID      `json:"course_participation_id"`
	PassStatus            NullPassStatus `json:"pass_status"`
	RestrictedData        []byte         `json:"restricted_data"`
	StudentReadableData   []byte         `json:"student_readable_data"`
}

// - We need to ensure that the course_participation_id and course_phase_id
// - belong to the same course.
func (q *Queries) CreateOrUpdateCoursePhaseParticipation(ctx context.Context, arg CreateOrUpdateCoursePhaseParticipationParams) (CoursePhaseParticipation, error) {
	row := q.db.QueryRow(ctx, createOrUpdateCoursePhaseParticipation,
		arg.CoursePhaseID,
		arg.CourseParticipationID,
		arg.PassStatus,
		arg.RestrictedData,
		arg.StudentReadableData,
	)
	var i CoursePhaseParticipation
	err := row.Scan(
		&i.CourseParticipationID,
		&i.CoursePhaseID,
		&i.RestrictedData,
		&i.PassStatus,
		&i.LastModified,
		&i.StudentReadableData,
	)
	return i, err
}

const getAllCoursePhaseParticipationsForCourseParticipation = `-- name: GetAllCoursePhaseParticipationsForCourseParticipation :many
SELECT course_participation_id, course_phase_id, restricted_data, pass_status, last_modified, student_readable_data FROM course_phase_participation
WHERE course_participation_id = $1
`

func (q *Queries) GetAllCoursePhaseParticipationsForCourseParticipation(ctx context.Context, courseParticipationID uuid.UUID) ([]CoursePhaseParticipation, error) {
	rows, err := q.db.Query(ctx, getAllCoursePhaseParticipationsForCourseParticipation, courseParticipationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoursePhaseParticipation
	for rows.Next() {
		var i CoursePhaseParticipation
		if err := rows.Scan(
			&i.CourseParticipationID,
			&i.CoursePhaseID,
			&i.RestrictedData,
			&i.PassStatus,
			&i.LastModified,
			&i.StudentReadableData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCoursePhaseParticipationsForCoursePhase = `-- name: GetAllCoursePhaseParticipationsForCoursePhase :many
SELECT
    cpp.pass_status,
    cpp.restricted_data,
    cpp.student_readable_data,
    s.id AS student_id,
    s.first_name,
    s.last_name,
    s.email,
    s.matriculation_number,
    s.university_login,
    s.has_university_account,
    s.gender
FROM
    course_phase_participation cpp
JOIN
    course_participation cp ON cpp.course_participation_id = cp.id
JOIN
    student s ON cp.student_id = s.id
WHERE
    cpp.course_phase_id = $1
`

type GetAllCoursePhaseParticipationsForCoursePhaseRow struct {
	PassStatus           NullPassStatus `json:"pass_status"`
	RestrictedData       []byte         `json:"restricted_data"`
	StudentReadableData  []byte         `json:"student_readable_data"`
	StudentID            uuid.UUID      `json:"student_id"`
	FirstName            pgtype.Text    `json:"first_name"`
	LastName             pgtype.Text    `json:"last_name"`
	Email                pgtype.Text    `json:"email"`
	MatriculationNumber  pgtype.Text    `json:"matriculation_number"`
	UniversityLogin      pgtype.Text    `json:"university_login"`
	HasUniversityAccount pgtype.Bool    `json:"has_university_account"`
	Gender               Gender         `json:"gender"`
}

func (q *Queries) GetAllCoursePhaseParticipationsForCoursePhase(ctx context.Context, coursePhaseID uuid.UUID) ([]GetAllCoursePhaseParticipationsForCoursePhaseRow, error) {
	rows, err := q.db.Query(ctx, getAllCoursePhaseParticipationsForCoursePhase, coursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCoursePhaseParticipationsForCoursePhaseRow
	for rows.Next() {
		var i GetAllCoursePhaseParticipationsForCoursePhaseRow
		if err := rows.Scan(
			&i.PassStatus,
			&i.RestrictedData,
			&i.StudentReadableData,
			&i.StudentID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.MatriculationNumber,
			&i.UniversityLogin,
			&i.HasUniversityAccount,
			&i.Gender,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCoursePhaseParticipationsForCoursePhaseIncludingPrevious = `-- name: GetAllCoursePhaseParticipationsForCoursePhaseIncludingPrevious :many
WITH 
  -----------------------------------------------------------------------
  -- A) Phases a student must have passed (per course_phase_graph)
  -----------------------------------------------------------------------
  direct_predecessor_for_pass AS (
      SELECT cpg.from_course_phase_id AS phase_id
      FROM course_phase_graph cpg
      WHERE cpg.to_course_phase_id = $1
  ),
  
  -----------------------------------------------------------------------
  -- B) Predecessor phases from which we pull meta data via meta_data_dependency_graph.
  -- Only include those whose course_phase_type has url = 'core'
  -- Copy the meta data from the predecessor to the current phase.
  -----------------------------------------------------------------------
  direct_predecessors_for_meta AS (
    SELECT 
      cpt.name                      AS from_course_phase_type_name,
      cpt.id                        AS from_course_phase_type_id,
      mdg.from_course_phase_id      AS from_course_phase_id,
      cp.restricted_data            AS course_phase_restricted_data,
      array_agg(po.dto_name)        AS from_dto_names -- all exported DTOs from this one phase from the core
    FROM meta_data_dependency_graph mdg
    JOIN course_phase cp 
        ON cp.id = mdg.from_course_phase_id
    JOIN course_phase_type cpt
        ON cpt.id = cp.course_phase_type_id
    JOIN course_phase_type_provided_output_dto po 
      ON po.id = mdg.from_course_phase_DTO_id
    JOIN course_phase_type_required_input_dto ri
      ON ri.id = mdg.to_course_phase_DTO_id
    WHERE mdg.to_course_phase_id = $1
      AND po.endpoint_path = 'core'
    GROUP BY 
      cpt.name,
      cpt.id,
      mdg.from_course_phase_id,
      cp.restricted_data
  ),
  
  -----------------------------------------------------------------------
  -- 1) Existing participants in the current phase
  -----------------------------------------------------------------------
  current_phase_participations AS (
      SELECT
          cpp.course_phase_id            AS course_phase_id,
          cpp.course_participation_id    AS course_participation_id,
          cpp.pass_status                AS pass_status,
          cpp.restricted_data            AS restricted_data,
          cpp.student_readable_data      AS student_readable_data,
          s.id                           AS student_id,
          s.first_name,
          s.last_name,
          s.email,
          s.matriculation_number,
          s.university_login,
          s.has_university_account,
          s.gender,
          s.nationality,
          s.study_degree,
          s.study_program,
          s.current_semester
      FROM course_phase_participation cpp
      JOIN course_participation cp 
        ON cpp.course_participation_id = cp.id
      JOIN student s 
        ON cp.student_id = s.id
      WHERE cpp.course_phase_id = $1
  ),
  
  -----------------------------------------------------------------------
  -- 2) Qualified non-participants:
  --    They do NOT yet have a participation in $1 and
  --    must have passed ALL direct_predecessors_for_pass.
  -----------------------------------------------------------------------
  qualified_non_participants AS (
      SELECT
          $1::uuid                     AS course_phase_id,
          cp.id                        AS course_participation_id,
          'not_assessed'::pass_status  AS pass_status,
          '{}'::jsonb                  AS restricted_data,
          '{}'::jsonb                  AS student_readable_data,
          s.id                         AS student_id,
          s.first_name,
          s.last_name,
          s.email,
          s.matriculation_number,
          s.university_login,
          s.has_university_account,
          s.gender,
          s.nationality,
          s.study_degree,
          s.study_program,
          s.current_semester
      FROM course_participation cp
      JOIN student s 
        ON cp.student_id = s.id
      WHERE 
          -- Exclude if they already have a participation in the current phase
          NOT EXISTS (
            SELECT 1
            FROM course_phase_participation new_cpp
            WHERE new_cpp.course_phase_id = $1
              AND new_cpp.course_participation_id = cp.id
          )
          -- And ensure they have 'passed' the direct predecessor (if any)
          AND EXISTS (
              SELECT 1
              FROM direct_predecessor_for_pass dpp
              JOIN course_phase_participation pcpp
                ON pcpp.course_phase_id = dpp.phase_id
                AND pcpp.course_participation_id = cp.id
              WHERE pcpp.pass_status = 'passed'
          )
  )
  
SELECT
    main.course_phase_id, main.course_participation_id, main.pass_status, main.restricted_data, main.student_readable_data, main.student_id, main.first_name, main.last_name, main.email, main.matriculation_number, main.university_login, main.has_university_account, main.gender, main.nationality, main.study_degree, main.study_program, main.current_semester,
    (COALESCE(      
      (
            ----------------------------------------------------------------
            -- (I) Meta data from non-Application phases
            ----------------------------------------------------------------
            SELECT jsonb_object_agg(each.key, each.value)
            FROM direct_predecessors_for_meta dpm
            JOIN course_phase_participation pcpp
              ON pcpp.course_phase_id = dpm.from_course_phase_id
             AND pcpp.course_participation_id = main.course_participation_id
            CROSS JOIN LATERAL (
              SELECT key, value
              FROM (
                SELECT (jsonb_each(pcpp.student_readable_data)).key   AS key,
                       (jsonb_each(pcpp.student_readable_data)).value AS value
                UNION
                SELECT (jsonb_each(pcpp.restricted_data)).key   AS key,
                       (jsonb_each(pcpp.restricted_data)).value AS value
              ) sub
            ) AS each
            WHERE dpm.from_course_phase_type_name <> 'Application'
              AND each.key = ANY(dpm.from_dto_names)
         ),
         '{}'::jsonb
      )::jsonb ||
      COALESCE(
          (
             -- (II) Meta data from the Application phase (special handling)
            SELECT appdata.obj
            FROM direct_predecessors_for_meta dpm
            JOIN course_phase_participation pcpp
              ON pcpp.course_phase_id = dpm.from_course_phase_id
             AND pcpp.course_participation_id = main.course_participation_id
            JOIN course_phase_type cpt
              ON cpt.id = dpm.from_course_phase_type_id
             AND cpt.name = 'Application'
            CROSS JOIN LATERAL (
               SELECT jsonb_strip_nulls(
                  jsonb_build_object(
                     'score', CASE 
                         WHEN 'score' = ANY(dpm.from_dto_names) THEN 
                           (SELECT to_jsonb(aasm.score)
                            FROM application_assessment aasm
                            WHERE aasm.course_phase_id = pcpp.course_phase_id AND aasm.course_participation_id = pcpp.course_participation_id)
                         ELSE NULL 
                     END,
                     'additionalScores', CASE 
                         WHEN 'additionalScores' = ANY(dpm.from_dto_names) THEN 
                           (SELECT jsonb_agg(
                                  jsonb_build_object(
                                    'key', question_config->>'key',
                                    'answer', pcpp.restricted_data -> (question_config->>'key')
                                  )
                           )
                            FROM jsonb_array_elements(dpm.course_phase_restricted_data->'additionalScores') question_config)
                         ELSE NULL 
                     END,
                     'applicationAnswers', CASE 
                         WHEN 'applicationAnswers' = ANY(dpm.from_dto_names) THEN 
                           (SELECT jsonb_agg(answer_obj)
                            FROM (
                               -- Text answers
                               SELECT jsonb_build_object(
                                  'key', qt.access_key,
                                  'answer', to_jsonb(aat.answer),
                                  'order_num', qt.order_num, 
                                  'type', 'text'
                               ) AS answer_obj
                               FROM application_question_text qt
                               JOIN application_answer_text aat
                                 ON aat.application_question_id = qt.id
                                AND aat.course_phase_id = pcpp.course_phase_id
                                AND aat.course_participation_id = pcpp.course_participation_id
                               WHERE qt.course_phase_id = dpm.from_course_phase_id
                                 AND qt.accessible_for_other_phases = true
                                 AND qt.access_key IS NOT NULL
                                 AND qt.access_key <> ''
                               UNION ALL
                               -- Multi-select answers
                               SELECT jsonb_build_object(
                                  'key', qm.access_key,
                                  'answer', to_jsonb(aams.answer),
                                  'order_num', qm.order_num, 
                                  'type', 'multiselect'
                               ) AS answer_obj
                               FROM application_question_multi_select qm
                               JOIN application_answer_multi_select aams
                                 ON aams.application_question_id = qm.id
                                AND aams.course_phase_id = pcpp.course_phase_id
                                AND aams.course_participation_id = pcpp.course_participation_id
                               WHERE qm.course_phase_id = dpm.from_course_phase_id
                                 AND qm.accessible_for_other_phases = true
                                 AND qm.access_key IS NOT NULL
                                 AND qm.access_key <> ''
                            ) answer_union)
                         ELSE NULL 
                     END
                  )
               ) AS obj
            ) appdata
         ),
         '{}'::jsonb
      )::jsonb)::jsonb AS prev_data
FROM
(
    SELECT course_phase_id, course_participation_id, pass_status, restricted_data, student_readable_data, student_id, first_name, last_name, email, matriculation_number, university_login, has_university_account, gender, nationality, study_degree, study_program, current_semester FROM current_phase_participations
    UNION
    SELECT course_phase_id, course_participation_id, pass_status, restricted_data, student_readable_data, student_id, first_name, last_name, email, matriculation_number, university_login, has_university_account, gender, nationality, study_degree, study_program, current_semester FROM qualified_non_participants
) AS main
ORDER BY main.last_name, main.first_name
`

type GetAllCoursePhaseParticipationsForCoursePhaseIncludingPreviousRow struct {
	CoursePhaseID         uuid.UUID      `json:"course_phase_id"`
	CourseParticipationID uuid.UUID      `json:"course_participation_id"`
	PassStatus            NullPassStatus `json:"pass_status"`
	RestrictedData        []byte         `json:"restricted_data"`
	StudentReadableData   []byte         `json:"student_readable_data"`
	StudentID             uuid.UUID      `json:"student_id"`
	FirstName             pgtype.Text    `json:"first_name"`
	LastName              pgtype.Text    `json:"last_name"`
	Email                 pgtype.Text    `json:"email"`
	MatriculationNumber   pgtype.Text    `json:"matriculation_number"`
	UniversityLogin       pgtype.Text    `json:"university_login"`
	HasUniversityAccount  pgtype.Bool    `json:"has_university_account"`
	Gender                Gender         `json:"gender"`
	Nationality           pgtype.Text    `json:"nationality"`
	StudyDegree           StudyDegree    `json:"study_degree"`
	StudyProgram          pgtype.Text    `json:"study_program"`
	CurrentSemester       pgtype.Int4    `json:"current_semester"`
	PrevData              []byte         `json:"prev_data"`
}

// ---------------------------------------------------------------------
// 3) Final SELECT: Merge the participants and meta data from all predecessors
// ---------------------------------------------------------------------
func (q *Queries) GetAllCoursePhaseParticipationsForCoursePhaseIncludingPrevious(ctx context.Context, toCoursePhaseID uuid.UUID) ([]GetAllCoursePhaseParticipationsForCoursePhaseIncludingPreviousRow, error) {
	rows, err := q.db.Query(ctx, getAllCoursePhaseParticipationsForCoursePhaseIncludingPrevious, toCoursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCoursePhaseParticipationsForCoursePhaseIncludingPreviousRow
	for rows.Next() {
		var i GetAllCoursePhaseParticipationsForCoursePhaseIncludingPreviousRow
		if err := rows.Scan(
			&i.CoursePhaseID,
			&i.CourseParticipationID,
			&i.PassStatus,
			&i.RestrictedData,
			&i.StudentReadableData,
			&i.StudentID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.MatriculationNumber,
			&i.UniversityLogin,
			&i.HasUniversityAccount,
			&i.Gender,
			&i.Nationality,
			&i.StudyDegree,
			&i.StudyProgram,
			&i.CurrentSemester,
			&i.PrevData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoursePhaseParticipation = `-- name: GetCoursePhaseParticipation :one
SELECT course_participation_id, course_phase_id, restricted_data, pass_status, last_modified, student_readable_data FROM course_phase_participation
WHERE course_phase_id = $1 
  AND course_participation_id = $2
LIMIT 1
`

type GetCoursePhaseParticipationParams struct {
	CoursePhaseID         uuid.UUID `json:"course_phase_id"`
	CourseParticipationID uuid.UUID `json:"course_participation_id"`
}

func (q *Queries) GetCoursePhaseParticipation(ctx context.Context, arg GetCoursePhaseParticipationParams) (CoursePhaseParticipation, error) {
	row := q.db.QueryRow(ctx, getCoursePhaseParticipation, arg.CoursePhaseID, arg.CourseParticipationID)
	var i CoursePhaseParticipation
	err := row.Scan(
		&i.CourseParticipationID,
		&i.CoursePhaseID,
		&i.RestrictedData,
		&i.PassStatus,
		&i.LastModified,
		&i.StudentReadableData,
	)
	return i, err
}

const getCoursePhaseParticipationByCourseParticipationAndCoursePhase = `-- name: GetCoursePhaseParticipationByCourseParticipationAndCoursePhase :one

SELECT course_participation_id, course_phase_id, restricted_data, pass_status, last_modified, student_readable_data FROM course_phase_participation
WHERE course_participation_id = $1 AND course_phase_id = $2 LIMIT 1
`

type GetCoursePhaseParticipationByCourseParticipationAndCoursePhaseParams struct {
	CourseParticipationID uuid.UUID `json:"course_participation_id"`
	CoursePhaseID         uuid.UUID `json:"course_phase_id"`
}

// important to trigger a no rows in result set error if ids mismatch
func (q *Queries) GetCoursePhaseParticipationByCourseParticipationAndCoursePhase(ctx context.Context, arg GetCoursePhaseParticipationByCourseParticipationAndCoursePhaseParams) (CoursePhaseParticipation, error) {
	row := q.db.QueryRow(ctx, getCoursePhaseParticipationByCourseParticipationAndCoursePhase, arg.CourseParticipationID, arg.CoursePhaseID)
	var i CoursePhaseParticipation
	err := row.Scan(
		&i.CourseParticipationID,
		&i.CoursePhaseID,
		&i.RestrictedData,
		&i.PassStatus,
		&i.LastModified,
		&i.StudentReadableData,
	)
	return i, err
}

const getCoursePhaseParticipationByUniversityLoginAndCoursePhase = `-- name: GetCoursePhaseParticipationByUniversityLoginAndCoursePhase :one
WITH 
direct_predecessor_for_pass AS (
    SELECT cpg.from_course_phase_id AS phase_id
    FROM course_phase_graph cpg
    WHERE cpg.to_course_phase_id = $1
),

current_phase_participation AS (
    SELECT
        cpp.course_phase_id            AS course_phase_id,
        cpp.course_participation_id    AS course_participation_id,
        cpp.student_readable_data      AS student_readable_data,
        s.id                           AS student_id,
        s.first_name,
        s.last_name,
        s.email,
        s.matriculation_number,
        s.university_login,
        s.has_university_account,
        s.gender,
        s.nationality,
        s.study_degree,
        s.study_program,
        s.current_semester
    FROM course_phase_participation cpp
    INNER JOIN course_participation cp 
      ON cpp.course_participation_id = cp.id
    INNER JOIN student s 
      ON cp.student_id = s.id
    WHERE cpp.course_phase_id = $1
      AND s.university_login = $2
      AND s.matriculation_number = $3 
),

qualified_non_participant AS (
    SELECT
        $1::uuid                     AS course_phase_id,
        cp.id                        AS course_participation_id,
        s.id                         AS student_id,
        s.first_name,
        s.last_name,
        s.email,
        s.matriculation_number,
        s.university_login,
        s.has_university_account,
        s.gender,
        s.nationality,
        s.study_degree,
        s.study_program,
        s.current_semester
    FROM course_participation cp
    JOIN student s 
      ON cp.student_id = s.id

    WHERE 
      s.university_login = $2
      AND s.matriculation_number = $3 
      -- Exclude if they already have a participation in the current phase
      AND NOT EXISTS (
        SELECT 1
        FROM course_phase_participation new_cpp
        WHERE new_cpp.course_phase_id = $1
          AND new_cpp.course_participation_id = cp.id
      )
    -- And ensure they have 'passed' in the previous phase 
    -- We filter just previous, not all since phase order might change or allow for non-linear courses at some point
    AND EXISTS (
        SELECT 1
        FROM direct_predecessor_for_pass dpp
        JOIN  course_phase_participation pcpp
          ON pcpp.course_phase_id = dpp.phase_id
          AND pcpp.course_participation_id = cp.id
        WHERE (pcpp.pass_status = 'passed')
    )
)
SELECT main.course_phase_id, main.course_participation_id, main.student_readable_data, main.student_id, main.first_name, main.last_name, main.email, main.matriculation_number, main.university_login, main.has_university_account, main.gender, main.nationality, main.study_degree, main.study_program, main.current_semester
FROM
(
    SELECT course_phase_id, course_participation_id, student_readable_data, student_id, first_name, last_name, email, matriculation_number, university_login, has_university_account, gender, nationality, study_degree, study_program, current_semester FROM current_phase_participation
    UNION
    SELECT course_phase_id, course_participation_id, student_id, first_name, last_name, email, matriculation_number, university_login, has_university_account, gender, nationality, study_degree, study_program, current_semester FROM qualified_non_participant
) AS main
LIMIT 1
`

type GetCoursePhaseParticipationByUniversityLoginAndCoursePhaseParams struct {
	ToCoursePhaseID     uuid.UUID   `json:"to_course_phase_id"`
	UniversityLogin     pgtype.Text `json:"university_login"`
	MatriculationNumber pgtype.Text `json:"matriculation_number"`
}

type GetCoursePhaseParticipationByUniversityLoginAndCoursePhaseRow struct {
	CoursePhaseID         uuid.UUID   `json:"course_phase_id"`
	CourseParticipationID uuid.UUID   `json:"course_participation_id"`
	StudentReadableData   []byte      `json:"student_readable_data"`
	StudentID             uuid.UUID   `json:"student_id"`
	FirstName             pgtype.Text `json:"first_name"`
	LastName              pgtype.Text `json:"last_name"`
	Email                 pgtype.Text `json:"email"`
	MatriculationNumber   pgtype.Text `json:"matriculation_number"`
	UniversityLogin       pgtype.Text `json:"university_login"`
	HasUniversityAccount  pgtype.Bool `json:"has_university_account"`
	Gender                Gender      `json:"gender"`
	Nationality           pgtype.Text `json:"nationality"`
	StudyDegree           StudyDegree `json:"study_degree"`
	StudyProgram          pgtype.Text `json:"study_program"`
	CurrentSemester       pgtype.Int4 `json:"current_semester"`
}

// ---------------------------------------------------------------------
// A) Phases a student must have 'passed' (per course_phase_graph)
// Identify the single previous phase (if any) required for PASS
// ---------------------------------------------------------------------
// ---------------------------------------------------------------------
// 1) Existing participants in the current phase
// ---------------------------------------------------------------------
// ---------------------------------------------------------------------
// 2) Would-be participants:
//   - They do NOT yet have a course_phase_participation for $1
//   - Must have passed ALL direct_predecessors_for_pass
//
// ---------------------------------------------------------------------
func (q *Queries) GetCoursePhaseParticipationByUniversityLoginAndCoursePhase(ctx context.Context, arg GetCoursePhaseParticipationByUniversityLoginAndCoursePhaseParams) (GetCoursePhaseParticipationByUniversityLoginAndCoursePhaseRow, error) {
	row := q.db.QueryRow(ctx, getCoursePhaseParticipationByUniversityLoginAndCoursePhase, arg.ToCoursePhaseID, arg.UniversityLogin, arg.MatriculationNumber)
	var i GetCoursePhaseParticipationByUniversityLoginAndCoursePhaseRow
	err := row.Scan(
		&i.CoursePhaseID,
		&i.CourseParticipationID,
		&i.StudentReadableData,
		&i.StudentID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.MatriculationNumber,
		&i.UniversityLogin,
		&i.HasUniversityAccount,
		&i.Gender,
		&i.Nationality,
		&i.StudyDegree,
		&i.StudyProgram,
		&i.CurrentSemester,
	)
	return i, err
}

const updateCoursePhaseParticipation = `-- name: UpdateCoursePhaseParticipation :one
UPDATE course_phase_participation
SET 
    pass_status = COALESCE($3, pass_status),   
    restricted_data = restricted_data || $4, 
    student_readable_data = student_readable_data || $5
WHERE course_phase_id = $1
  AND course_participation_id = $2
RETURNING course_phase_id, course_participation_id
`

type UpdateCoursePhaseParticipationParams struct {
	CoursePhaseID         uuid.UUID      `json:"course_phase_id"`
	CourseParticipationID uuid.UUID      `json:"course_participation_id"`
	PassStatus            NullPassStatus `json:"pass_status"`
	RestrictedData        []byte         `json:"restricted_data"`
	StudentReadableData   []byte         `json:"student_readable_data"`
}

type UpdateCoursePhaseParticipationRow struct {
	CoursePhaseID         uuid.UUID `json:"course_phase_id"`
	CourseParticipationID uuid.UUID `json:"course_participation_id"`
}

func (q *Queries) UpdateCoursePhaseParticipation(ctx context.Context, arg UpdateCoursePhaseParticipationParams) (UpdateCoursePhaseParticipationRow, error) {
	row := q.db.QueryRow(ctx, updateCoursePhaseParticipation,
		arg.CoursePhaseID,
		arg.CourseParticipationID,
		arg.PassStatus,
		arg.RestrictedData,
		arg.StudentReadableData,
	)
	var i UpdateCoursePhaseParticipationRow
	err := row.Scan(&i.CoursePhaseID, &i.CourseParticipationID)
	return i, err
}

const updateCoursePhasePassStatus = `-- name: UpdateCoursePhasePassStatus :many
UPDATE course_phase_participation
SET pass_status = $3::pass_status
WHERE id = ANY($1::uuid[])
  AND course_phase_id = $2::uuid
  AND pass_status != $3::pass_status
RETURNING course_participation_id
`

type UpdateCoursePhasePassStatusParams struct {
	Column1 []uuid.UUID `json:"column_1"`
	Column2 uuid.UUID   `json:"column_2"`
	Column3 PassStatus  `json:"column_3"`
}

func (q *Queries) UpdateCoursePhasePassStatus(ctx context.Context, arg UpdateCoursePhasePassStatusParams) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, updateCoursePhasePassStatus, arg.Column1, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var course_participation_id uuid.UUID
		if err := rows.Scan(&course_participation_id); err != nil {
			return nil, err
		}
		items = append(items, course_participation_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
