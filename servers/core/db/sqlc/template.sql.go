// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: template.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const checkCourseTemplateStatus = `-- name: CheckCourseTemplateStatus :one
SELECT template
FROM course
WHERE id = $1
`

func (q *Queries) CheckCourseTemplateStatus(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, checkCourseTemplateStatus, id)
	var template bool
	err := row.Scan(&template)
	return template, err
}

const getTemplateCourseByID = `-- name: GetTemplateCourseByID :one
SELECT id, name, start_date, end_date, semester_tag, course_type, ects, restricted_data, student_readable_data, template
FROM course
WHERE id = $1
  AND template = TRUE
`

func (q *Queries) GetTemplateCourseByID(ctx context.Context, id uuid.UUID) (Course, error) {
	row := q.db.QueryRow(ctx, getTemplateCourseByID, id)
	var i Course
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.StartDate,
		&i.EndDate,
		&i.SemesterTag,
		&i.CourseType,
		&i.Ects,
		&i.RestrictedData,
		&i.StudentReadableData,
		&i.Template,
	)
	return i, err
}

const getTemplateCoursesAdmin = `-- name: GetTemplateCoursesAdmin :many
SELECT id, name, start_date, end_date, semester_tag, course_type, ects, restricted_data, student_readable_data, template
FROM course
WHERE template = TRUE
ORDER BY semester_tag, name DESC
`

func (q *Queries) GetTemplateCoursesAdmin(ctx context.Context) ([]Course, error) {
	rows, err := q.db.Query(ctx, getTemplateCoursesAdmin)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Course
	for rows.Next() {
		var i Course
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.StartDate,
			&i.EndDate,
			&i.SemesterTag,
			&i.CourseType,
			&i.Ects,
			&i.RestrictedData,
			&i.StudentReadableData,
			&i.Template,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTemplateCoursesRestricted = `-- name: GetTemplateCoursesRestricted :many
WITH parsed_roles AS (
  SELECT
    split_part(role, '-', 1) AS semester_tag,
    split_part(role, '-', 2) AS course_name,
    split_part(role, '-', 3) AS user_role
  FROM
    unnest($1::text[]) AS role
),
user_course_roles AS (
  SELECT
    c.id,
    c.name,
    c.semester_tag,
    c.start_date,
    c.end_date,
    c.course_type,
    c.student_readable_data,
    c.restricted_data,
    c.ects,
    c.template,
    pr.user_role
  FROM
    course c
  INNER JOIN
    parsed_roles pr
    ON c.name = pr.course_name
    AND c.semester_tag = pr.semester_tag
  WHERE
    c.template = TRUE
)
SELECT
  ucr.id,
  ucr.name,
  ucr.start_date,
  ucr.end_date,
  ucr.semester_tag,
  ucr.course_type,
  ucr.ects,
  CASE 
    WHEN COUNT(ucr.user_role) = 1 AND MAX(ucr.user_role) = 'Student' THEN '{}'::jsonb
    ELSE ucr.restricted_data::jsonb
  END AS restricted_data,
  ucr.student_readable_data,
  ucr.template
FROM
  user_course_roles ucr
GROUP BY
  ucr.id,
  ucr.name,
  ucr.semester_tag,
  ucr.start_date,
  ucr.end_date,
  ucr.course_type,
  ucr.student_readable_data,
  ucr.ects,
  ucr.restricted_data,
  ucr.template
ORDER BY
  ucr.semester_tag, ucr.name DESC
`

type GetTemplateCoursesRestrictedRow struct {
	ID                  uuid.UUID   `json:"id"`
	Name                string      `json:"name"`
	StartDate           pgtype.Date `json:"start_date"`
	EndDate             pgtype.Date `json:"end_date"`
	SemesterTag         pgtype.Text `json:"semester_tag"`
	CourseType          CourseType  `json:"course_type"`
	Ects                pgtype.Int4 `json:"ects"`
	RestrictedData      []byte      `json:"restricted_data"`
	StudentReadableData []byte      `json:"student_readable_data"`
	Template            bool        `json:"template"`
}

// struct: Course
func (q *Queries) GetTemplateCoursesRestricted(ctx context.Context, dollar_1 []string) ([]GetTemplateCoursesRestrictedRow, error) {
	rows, err := q.db.Query(ctx, getTemplateCoursesRestricted, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTemplateCoursesRestrictedRow
	for rows.Next() {
		var i GetTemplateCoursesRestrictedRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.StartDate,
			&i.EndDate,
			&i.SemesterTag,
			&i.CourseType,
			&i.Ects,
			&i.RestrictedData,
			&i.StudentReadableData,
			&i.Template,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markCourseAsTemplate = `-- name: MarkCourseAsTemplate :exec
UPDATE course
SET template = TRUE
WHERE id = $1
`

func (q *Queries) MarkCourseAsTemplate(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, markCourseAsTemplate, id)
	return err
}

const unmarkCourseAsTemplate = `-- name: UnmarkCourseAsTemplate :exec
UPDATE course
SET template = FALSE
WHERE id = $1
`

func (q *Queries) UnmarkCourseAsTemplate(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, unmarkCourseAsTemplate, id)
	return err
}
