// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: application.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const acceptApplicationIfAutoAccept = `-- name: AcceptApplicationIfAutoAccept :exec
UPDATE course_phase_participation
SET pass_status = 'passed'
WHERE course_phase_id = $1
  AND course_participation_id = $2
  AND (
    SELECT (restricted_data->>'autoAccept')::boolean
    FROM course_phase
    WHERE id = $1
  ) = true
`

type AcceptApplicationIfAutoAcceptParams struct {
	CoursePhaseID         uuid.UUID `json:"course_phase_id"`
	CourseParticipationID uuid.UUID `json:"course_participation_id"`
}

func (q *Queries) AcceptApplicationIfAutoAccept(ctx context.Context, arg AcceptApplicationIfAutoAcceptParams) error {
	_, err := q.db.Exec(ctx, acceptApplicationIfAutoAccept, arg.CoursePhaseID, arg.CourseParticipationID)
	return err
}

const batchUpdateAdditionalScores = `-- name: BatchUpdateAdditionalScores :exec
WITH updates AS (
  SELECT 
    UNNEST($2::uuid[]) AS course_participation_id,
    UNNEST($3::numeric[]) AS score,
    $4::text[] AS path -- Use $3 as a JSON path array
)
UPDATE course_phase_participation
SET    
    restricted_data = jsonb_set(
        COALESCE(restricted_data, '{}'),
        updates.path, -- Use dynamic path
        to_jsonb(ROUND(updates.score, 2)) -- Convert the float score to JSONB
    )
FROM updates
WHERE 
    course_phase_participation.course_participation_id = updates.course_participation_id
    AND course_phase_participation.course_phase_id = $1::uuid
`

type BatchUpdateAdditionalScoresParams struct {
	CoursePhaseID          uuid.UUID        `json:"course_phase_id"`
	CourseParticipationIds []uuid.UUID      `json:"course_participation_ids"`
	Scores                 []pgtype.Numeric `json:"scores"`
	ScoreName              []string         `json:"score_name"`
}

func (q *Queries) BatchUpdateAdditionalScores(ctx context.Context, arg BatchUpdateAdditionalScoresParams) error {
	_, err := q.db.Exec(ctx, batchUpdateAdditionalScores,
		arg.CoursePhaseID,
		arg.CourseParticipationIds,
		arg.Scores,
		arg.ScoreName,
	)
	return err
}

const checkIfCoursePhaseIsApplicationPhase = `-- name: CheckIfCoursePhaseIsApplicationPhase :one
SELECT 
    cpt.name = 'Application' AS is_application
FROM 
    course_phase cp
JOIN 
    course_phase_type cpt
ON 
    cp.course_phase_type_id = cpt.id
WHERE 
    cp.id = $1
`

func (q *Queries) CheckIfCoursePhaseIsApplicationPhase(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, checkIfCoursePhaseIsApplicationPhase, id)
	var is_application bool
	err := row.Scan(&is_application)
	return is_application, err
}

const checkIfCoursePhaseIsOpenApplicationPhase = `-- name: CheckIfCoursePhaseIsOpenApplicationPhase :one
SELECT 
    cpt.name = 'Application' AS is_application,
    (cp.restricted_data->>'universityLoginAvailable')::boolean AS university_login_available 
FROM 
    course_phase cp
JOIN 
    course_phase_type cpt
ON 
    cp.course_phase_type_id = cpt.id
WHERE 
    cp.id = $1
    AND (cp.restricted_data->>'applicationEndDate')::timestamp > NOW()
`

type CheckIfCoursePhaseIsOpenApplicationPhaseRow struct {
	IsApplication            bool `json:"is_application"`
	UniversityLoginAvailable bool `json:"university_login_available"`
}

func (q *Queries) CheckIfCoursePhaseIsOpenApplicationPhase(ctx context.Context, id uuid.UUID) (CheckIfCoursePhaseIsOpenApplicationPhaseRow, error) {
	row := q.db.QueryRow(ctx, checkIfCoursePhaseIsOpenApplicationPhase, id)
	var i CheckIfCoursePhaseIsOpenApplicationPhaseRow
	err := row.Scan(&i.IsApplication, &i.UniversityLoginAvailable)
	return i, err
}

const createApplicationAnswerMultiSelect = `-- name: CreateApplicationAnswerMultiSelect :exec
INSERT INTO application_answer_multi_select (id, application_question_id, course_participation_id, answer)
VALUES ($1, $2, $3, $4)
`

type CreateApplicationAnswerMultiSelectParams struct {
	ID                    uuid.UUID `json:"id"`
	ApplicationQuestionID uuid.UUID `json:"application_question_id"`
	CourseParticipationID uuid.UUID `json:"course_participation_id"`
	Answer                []string  `json:"answer"`
}

func (q *Queries) CreateApplicationAnswerMultiSelect(ctx context.Context, arg CreateApplicationAnswerMultiSelectParams) error {
	_, err := q.db.Exec(ctx, createApplicationAnswerMultiSelect,
		arg.ID,
		arg.ApplicationQuestionID,
		arg.CourseParticipationID,
		arg.Answer,
	)
	return err
}

const createApplicationAnswerText = `-- name: CreateApplicationAnswerText :exec
INSERT INTO application_answer_text (id, application_question_id, course_participation_id, answer)
VALUES ($1, $2, $3, $4)
`

type CreateApplicationAnswerTextParams struct {
	ID                    uuid.UUID   `json:"id"`
	ApplicationQuestionID uuid.UUID   `json:"application_question_id"`
	CourseParticipationID uuid.UUID   `json:"course_participation_id"`
	Answer                pgtype.Text `json:"answer"`
}

func (q *Queries) CreateApplicationAnswerText(ctx context.Context, arg CreateApplicationAnswerTextParams) error {
	_, err := q.db.Exec(ctx, createApplicationAnswerText,
		arg.ID,
		arg.ApplicationQuestionID,
		arg.CourseParticipationID,
		arg.Answer,
	)
	return err
}

const createApplicationQuestionMultiSelect = `-- name: CreateApplicationQuestionMultiSelect :exec
INSERT INTO application_question_multi_select (id, course_phase_id, title, description, placeholder, error_message, is_required, min_select, max_select, options, order_num, accessible_for_other_phases, access_key)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
`

type CreateApplicationQuestionMultiSelectParams struct {
	ID                       uuid.UUID   `json:"id"`
	CoursePhaseID            uuid.UUID   `json:"course_phase_id"`
	Title                    pgtype.Text `json:"title"`
	Description              pgtype.Text `json:"description"`
	Placeholder              pgtype.Text `json:"placeholder"`
	ErrorMessage             pgtype.Text `json:"error_message"`
	IsRequired               pgtype.Bool `json:"is_required"`
	MinSelect                pgtype.Int4 `json:"min_select"`
	MaxSelect                pgtype.Int4 `json:"max_select"`
	Options                  []string    `json:"options"`
	OrderNum                 pgtype.Int4 `json:"order_num"`
	AccessibleForOtherPhases pgtype.Bool `json:"accessible_for_other_phases"`
	AccessKey                pgtype.Text `json:"access_key"`
}

func (q *Queries) CreateApplicationQuestionMultiSelect(ctx context.Context, arg CreateApplicationQuestionMultiSelectParams) error {
	_, err := q.db.Exec(ctx, createApplicationQuestionMultiSelect,
		arg.ID,
		arg.CoursePhaseID,
		arg.Title,
		arg.Description,
		arg.Placeholder,
		arg.ErrorMessage,
		arg.IsRequired,
		arg.MinSelect,
		arg.MaxSelect,
		arg.Options,
		arg.OrderNum,
		arg.AccessibleForOtherPhases,
		arg.AccessKey,
	)
	return err
}

const createApplicationQuestionText = `-- name: CreateApplicationQuestionText :exec
INSERT INTO application_question_text (id, course_phase_id, title, description, placeholder, validation_regex, error_message, is_required, allowed_length, order_num, accessible_for_other_phases, access_key)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
`

type CreateApplicationQuestionTextParams struct {
	ID                       uuid.UUID   `json:"id"`
	CoursePhaseID            uuid.UUID   `json:"course_phase_id"`
	Title                    pgtype.Text `json:"title"`
	Description              pgtype.Text `json:"description"`
	Placeholder              pgtype.Text `json:"placeholder"`
	ValidationRegex          pgtype.Text `json:"validation_regex"`
	ErrorMessage             pgtype.Text `json:"error_message"`
	IsRequired               pgtype.Bool `json:"is_required"`
	AllowedLength            pgtype.Int4 `json:"allowed_length"`
	OrderNum                 pgtype.Int4 `json:"order_num"`
	AccessibleForOtherPhases pgtype.Bool `json:"accessible_for_other_phases"`
	AccessKey                pgtype.Text `json:"access_key"`
}

func (q *Queries) CreateApplicationQuestionText(ctx context.Context, arg CreateApplicationQuestionTextParams) error {
	_, err := q.db.Exec(ctx, createApplicationQuestionText,
		arg.ID,
		arg.CoursePhaseID,
		arg.Title,
		arg.Description,
		arg.Placeholder,
		arg.ValidationRegex,
		arg.ErrorMessage,
		arg.IsRequired,
		arg.AllowedLength,
		arg.OrderNum,
		arg.AccessibleForOtherPhases,
		arg.AccessKey,
	)
	return err
}

const createOrOverwriteApplicationAnswerMultiSelect = `-- name: CreateOrOverwriteApplicationAnswerMultiSelect :exec
INSERT INTO application_answer_multi_select (id, application_question_id, course_participation_id, answer)
VALUES ($1, $2, $3, $4)
ON CONFLICT (course_participation_id, application_question_id)
DO UPDATE
SET answer = EXCLUDED.answer
`

type CreateOrOverwriteApplicationAnswerMultiSelectParams struct {
	ID                    uuid.UUID `json:"id"`
	ApplicationQuestionID uuid.UUID `json:"application_question_id"`
	CourseParticipationID uuid.UUID `json:"course_participation_id"`
	Answer                []string  `json:"answer"`
}

func (q *Queries) CreateOrOverwriteApplicationAnswerMultiSelect(ctx context.Context, arg CreateOrOverwriteApplicationAnswerMultiSelectParams) error {
	_, err := q.db.Exec(ctx, createOrOverwriteApplicationAnswerMultiSelect,
		arg.ID,
		arg.ApplicationQuestionID,
		arg.CourseParticipationID,
		arg.Answer,
	)
	return err
}

const createOrOverwriteApplicationAnswerText = `-- name: CreateOrOverwriteApplicationAnswerText :exec
INSERT INTO application_answer_text (id, application_question_id, course_participation_id, answer)
VALUES ($1, $2, $3, $4)
ON CONFLICT (course_participation_id, application_question_id)
DO UPDATE
SET answer = EXCLUDED.answer
`

type CreateOrOverwriteApplicationAnswerTextParams struct {
	ID                    uuid.UUID   `json:"id"`
	ApplicationQuestionID uuid.UUID   `json:"application_question_id"`
	CourseParticipationID uuid.UUID   `json:"course_participation_id"`
	Answer                pgtype.Text `json:"answer"`
}

func (q *Queries) CreateOrOverwriteApplicationAnswerText(ctx context.Context, arg CreateOrOverwriteApplicationAnswerTextParams) error {
	_, err := q.db.Exec(ctx, createOrOverwriteApplicationAnswerText,
		arg.ID,
		arg.ApplicationQuestionID,
		arg.CourseParticipationID,
		arg.Answer,
	)
	return err
}

const deleteApplicationQuestionMultiSelect = `-- name: DeleteApplicationQuestionMultiSelect :exec
DELETE FROM application_question_multi_select
WHERE id = $1
`

func (q *Queries) DeleteApplicationQuestionMultiSelect(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteApplicationQuestionMultiSelect, id)
	return err
}

const deleteApplicationQuestionText = `-- name: DeleteApplicationQuestionText :exec
DELETE FROM application_question_text
WHERE id = $1
`

func (q *Queries) DeleteApplicationQuestionText(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteApplicationQuestionText, id)
	return err
}

const deleteApplications = `-- name: DeleteApplications :exec
DELETE FROM course_participation
WHERE id IN (
      SELECT cpp.course_participation_id
      FROM course_phase_participation cpp
      WHERE cpp.course_participation_id = ANY($1::uuid[])
        AND cpp.course_phase_id = $2::uuid -- ensures that only applications for the given course phase are deleted
  )
`

type DeleteApplicationsParams struct {
	CourseParticipationIds []uuid.UUID `json:"course_participation_ids"`
	CoursePhaseID          uuid.UUID   `json:"course_phase_id"`
}

func (q *Queries) DeleteApplications(ctx context.Context, arg DeleteApplicationsParams) error {
	_, err := q.db.Exec(ctx, deleteApplications, arg.CourseParticipationIds, arg.CoursePhaseID)
	return err
}

const getAllApplicationParticipations = `-- name: GetAllApplicationParticipations :many
SELECT
    cpp.course_phase_id,
    cpp.course_participation_id,
    cpp.pass_status,
    cpp.restricted_data,
    s.id AS student_id,
    s.first_name,
    s.last_name,
    s.email,
    s.matriculation_number,
    s.university_login,
    s.has_university_account,
    s.gender, 
    s.nationality,
    s.study_degree,
    s.study_program,
    s.current_semester,
    a.score
FROM
    course_phase_participation cpp
JOIN
    course_participation cp ON cpp.course_participation_id = cp.id
JOIN
    student s ON cp.student_id = s.id
LEFT JOIN
    application_assessment a ON cpp.course_participation_id = a.course_participation_id AND cpp.course_phase_id = a.course_phase_id
WHERE
    cpp.course_phase_id = $1
`

type GetAllApplicationParticipationsRow struct {
	CoursePhaseID         uuid.UUID      `json:"course_phase_id"`
	CourseParticipationID uuid.UUID      `json:"course_participation_id"`
	PassStatus            NullPassStatus `json:"pass_status"`
	RestrictedData        []byte         `json:"restricted_data"`
	StudentID             uuid.UUID      `json:"student_id"`
	FirstName             pgtype.Text    `json:"first_name"`
	LastName              pgtype.Text    `json:"last_name"`
	Email                 pgtype.Text    `json:"email"`
	MatriculationNumber   pgtype.Text    `json:"matriculation_number"`
	UniversityLogin       pgtype.Text    `json:"university_login"`
	HasUniversityAccount  pgtype.Bool    `json:"has_university_account"`
	Gender                Gender         `json:"gender"`
	Nationality           pgtype.Text    `json:"nationality"`
	StudyDegree           StudyDegree    `json:"study_degree"`
	StudyProgram          pgtype.Text    `json:"study_program"`
	CurrentSemester       pgtype.Int4    `json:"current_semester"`
	Score                 pgtype.Int4    `json:"score"`
}

func (q *Queries) GetAllApplicationParticipations(ctx context.Context, coursePhaseID uuid.UUID) ([]GetAllApplicationParticipationsRow, error) {
	rows, err := q.db.Query(ctx, getAllApplicationParticipations, coursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllApplicationParticipationsRow
	for rows.Next() {
		var i GetAllApplicationParticipationsRow
		if err := rows.Scan(
			&i.CoursePhaseID,
			&i.CourseParticipationID,
			&i.PassStatus,
			&i.RestrictedData,
			&i.StudentID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.MatriculationNumber,
			&i.UniversityLogin,
			&i.HasUniversityAccount,
			&i.Gender,
			&i.Nationality,
			&i.StudyDegree,
			&i.StudyProgram,
			&i.CurrentSemester,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllOpenApplicationPhases = `-- name: GetAllOpenApplicationPhases :many
SELECT 
    cp.id AS course_phase_id,
    c.name AS course_name,
    c.start_date, 
    c.end_date,
    c.course_type, 
    c.ects,
    (cp.restricted_data->>'applicationEndDate')::text AS application_end_date,
    (cp.restricted_data->>'externalStudentsAllowed')::boolean AS external_students_allowed,
    (cp.restricted_data->>'universityLoginAvailable')::boolean AS university_login_available
FROM 
    course_phase cp
JOIN 
    course_phase_type cpt
    ON cp.course_phase_type_id = cpt.id
JOIN 
    course c
    ON cp.course_id = c.id
WHERE 
    cp.is_initial_phase = true
    AND cpt.name = 'Application'
    AND (cp.restricted_data->>'applicationEndDate')::timestamp > NOW()
    AND (cp.restricted_data->>'applicationStartDate')::timestamp < NOW()
`

type GetAllOpenApplicationPhasesRow struct {
	CoursePhaseID            uuid.UUID   `json:"course_phase_id"`
	CourseName               string      `json:"course_name"`
	StartDate                pgtype.Date `json:"start_date"`
	EndDate                  pgtype.Date `json:"end_date"`
	CourseType               CourseType  `json:"course_type"`
	Ects                     pgtype.Int4 `json:"ects"`
	ApplicationEndDate       string      `json:"application_end_date"`
	ExternalStudentsAllowed  bool        `json:"external_students_allowed"`
	UniversityLoginAvailable bool        `json:"university_login_available"`
}

func (q *Queries) GetAllOpenApplicationPhases(ctx context.Context) ([]GetAllOpenApplicationPhasesRow, error) {
	rows, err := q.db.Query(ctx, getAllOpenApplicationPhases)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllOpenApplicationPhasesRow
	for rows.Next() {
		var i GetAllOpenApplicationPhasesRow
		if err := rows.Scan(
			&i.CoursePhaseID,
			&i.CourseName,
			&i.StartDate,
			&i.EndDate,
			&i.CourseType,
			&i.Ects,
			&i.ApplicationEndDate,
			&i.ExternalStudentsAllowed,
			&i.UniversityLoginAvailable,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplicationAnswersMultiSelectForCourseParticipationID = `-- name: GetApplicationAnswersMultiSelectForCourseParticipationID :many
SELECT aams.id, aams.application_question_id, aams.answer, aams.course_participation_id
FROM application_answer_multi_select aams
JOIN application_question_multi_select aqms ON aams.application_question_id = aqms.id
WHERE aqms.course_phase_id = $1 AND aams.course_participation_id = $2
`

type GetApplicationAnswersMultiSelectForCourseParticipationIDParams struct {
	CoursePhaseID         uuid.UUID `json:"course_phase_id"`
	CourseParticipationID uuid.UUID `json:"course_participation_id"`
}

func (q *Queries) GetApplicationAnswersMultiSelectForCourseParticipationID(ctx context.Context, arg GetApplicationAnswersMultiSelectForCourseParticipationIDParams) ([]ApplicationAnswerMultiSelect, error) {
	rows, err := q.db.Query(ctx, getApplicationAnswersMultiSelectForCourseParticipationID, arg.CoursePhaseID, arg.CourseParticipationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApplicationAnswerMultiSelect
	for rows.Next() {
		var i ApplicationAnswerMultiSelect
		if err := rows.Scan(
			&i.ID,
			&i.ApplicationQuestionID,
			&i.Answer,
			&i.CourseParticipationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplicationAnswersTextForCourseParticipationID = `-- name: GetApplicationAnswersTextForCourseParticipationID :many
SELECT aat.id, aat.application_question_id, aat.answer, aat.course_participation_id
FROM application_answer_text aat
JOIN application_question_text aqt ON aat.application_question_id = aqt.id
WHERE aqt.course_phase_id = $1 AND aat.course_participation_id = $2
`

type GetApplicationAnswersTextForCourseParticipationIDParams struct {
	CoursePhaseID         uuid.UUID `json:"course_phase_id"`
	CourseParticipationID uuid.UUID `json:"course_participation_id"`
}

func (q *Queries) GetApplicationAnswersTextForCourseParticipationID(ctx context.Context, arg GetApplicationAnswersTextForCourseParticipationIDParams) ([]ApplicationAnswerText, error) {
	rows, err := q.db.Query(ctx, getApplicationAnswersTextForCourseParticipationID, arg.CoursePhaseID, arg.CourseParticipationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApplicationAnswerText
	for rows.Next() {
		var i ApplicationAnswerText
		if err := rows.Scan(
			&i.ID,
			&i.ApplicationQuestionID,
			&i.Answer,
			&i.CourseParticipationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplicationExists = `-- name: GetApplicationExists :one
SELECT EXISTS (
    SELECT 1
    FROM course_phase_participation cpp
    WHERE cpp.course_phase_id = $1
    AND cpp.course_participation_id = $2
)
`

type GetApplicationExistsParams struct {
	CoursePhaseID         uuid.UUID `json:"course_phase_id"`
	CourseParticipationID uuid.UUID `json:"course_participation_id"`
}

func (q *Queries) GetApplicationExists(ctx context.Context, arg GetApplicationExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, getApplicationExists, arg.CoursePhaseID, arg.CourseParticipationID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getApplicationExistsForStudent = `-- name: GetApplicationExistsForStudent :one
SELECT EXISTS (
    SELECT 1
    FROM course_participation cp
    INNER JOIN course_phase ph ON cp.course_id = ph.course_id
    WHERE cp.student_id = $1 AND ph.id = $2
)
`

type GetApplicationExistsForStudentParams struct {
	StudentID uuid.UUID `json:"student_id"`
	ID        uuid.UUID `json:"id"`
}

func (q *Queries) GetApplicationExistsForStudent(ctx context.Context, arg GetApplicationExistsForStudentParams) (bool, error) {
	row := q.db.QueryRow(ctx, getApplicationExistsForStudent, arg.StudentID, arg.ID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getApplicationQuestionsMultiSelectForCoursePhase = `-- name: GetApplicationQuestionsMultiSelectForCoursePhase :many
SELECT id, course_phase_id, title, description, placeholder, error_message, is_required, min_select, max_select, options, order_num, accessible_for_other_phases, access_key FROM application_question_multi_select
WHERE course_phase_id = $1
`

func (q *Queries) GetApplicationQuestionsMultiSelectForCoursePhase(ctx context.Context, coursePhaseID uuid.UUID) ([]ApplicationQuestionMultiSelect, error) {
	rows, err := q.db.Query(ctx, getApplicationQuestionsMultiSelectForCoursePhase, coursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApplicationQuestionMultiSelect
	for rows.Next() {
		var i ApplicationQuestionMultiSelect
		if err := rows.Scan(
			&i.ID,
			&i.CoursePhaseID,
			&i.Title,
			&i.Description,
			&i.Placeholder,
			&i.ErrorMessage,
			&i.IsRequired,
			&i.MinSelect,
			&i.MaxSelect,
			&i.Options,
			&i.OrderNum,
			&i.AccessibleForOtherPhases,
			&i.AccessKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplicationQuestionsTextForCoursePhase = `-- name: GetApplicationQuestionsTextForCoursePhase :many
SELECT id, course_phase_id, title, description, placeholder, validation_regex, error_message, is_required, allowed_length, order_num, accessible_for_other_phases, access_key FROM application_question_text
WHERE course_phase_id = $1
`

func (q *Queries) GetApplicationQuestionsTextForCoursePhase(ctx context.Context, coursePhaseID uuid.UUID) ([]ApplicationQuestionText, error) {
	rows, err := q.db.Query(ctx, getApplicationQuestionsTextForCoursePhase, coursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApplicationQuestionText
	for rows.Next() {
		var i ApplicationQuestionText
		if err := rows.Scan(
			&i.ID,
			&i.CoursePhaseID,
			&i.Title,
			&i.Description,
			&i.Placeholder,
			&i.ValidationRegex,
			&i.ErrorMessage,
			&i.IsRequired,
			&i.AllowedLength,
			&i.OrderNum,
			&i.AccessibleForOtherPhases,
			&i.AccessKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExistingAdditionalScores = `-- name: GetExistingAdditionalScores :one
SELECT 
    restricted_data->>'additional_scores' AS additional_scores
FROM
    course_phase
WHERE
    id = $1
`

func (q *Queries) GetExistingAdditionalScores(ctx context.Context, id uuid.UUID) (interface{}, error) {
	row := q.db.QueryRow(ctx, getExistingAdditionalScores, id)
	var additional_scores interface{}
	err := row.Scan(&additional_scores)
	return additional_scores, err
}

const getOpenApplicationPhase = `-- name: GetOpenApplicationPhase :one
SELECT 
    cp.id AS course_phase_id,
    c.name AS course_name,
    c.start_date, 
    c.end_date,
    c.course_type, 
    c.ects,
    (cp.restricted_data->>'applicationEndDate')::text AS application_end_date,
    (cp.restricted_data->>'externalStudentsAllowed')::boolean AS external_students_allowed,
    (cp.restricted_data->>'universityLoginAvailable')::boolean AS university_login_available
FROM 
    course_phase cp
JOIN 
    course_phase_type cpt
    ON cp.course_phase_type_id = cpt.id
JOIN 
    course c
    ON cp.course_id = c.id
WHERE 
    cp.id = $1
    AND cp.is_initial_phase = true
    AND cpt.name = 'Application'
    AND (cp.restricted_data->>'applicationEndDate')::timestamp > NOW()
    AND (cp.restricted_data->>'applicationStartDate')::timestamp < NOW()
`

type GetOpenApplicationPhaseRow struct {
	CoursePhaseID            uuid.UUID   `json:"course_phase_id"`
	CourseName               string      `json:"course_name"`
	StartDate                pgtype.Date `json:"start_date"`
	EndDate                  pgtype.Date `json:"end_date"`
	CourseType               CourseType  `json:"course_type"`
	Ects                     pgtype.Int4 `json:"ects"`
	ApplicationEndDate       string      `json:"application_end_date"`
	ExternalStudentsAllowed  bool        `json:"external_students_allowed"`
	UniversityLoginAvailable bool        `json:"university_login_available"`
}

func (q *Queries) GetOpenApplicationPhase(ctx context.Context, id uuid.UUID) (GetOpenApplicationPhaseRow, error) {
	row := q.db.QueryRow(ctx, getOpenApplicationPhase, id)
	var i GetOpenApplicationPhaseRow
	err := row.Scan(
		&i.CoursePhaseID,
		&i.CourseName,
		&i.StartDate,
		&i.EndDate,
		&i.CourseType,
		&i.Ects,
		&i.ApplicationEndDate,
		&i.ExternalStudentsAllowed,
		&i.UniversityLoginAvailable,
	)
	return i, err
}

const storeApplicationAnswerUpdateTimestamp = `-- name: StoreApplicationAnswerUpdateTimestamp :exec
UPDATE course_phase_participation
SET restricted_data = jsonb_set(
    COALESCE(restricted_data, '{}'), -- Ensure meta_data is not NULL
    '{student_last_modified}', -- Path to the key
    to_jsonb(NOW())::jsonb     -- Value to set
)
WHERE 
 course_phase_id = $1
 AND course_participation_id = $2
`

type StoreApplicationAnswerUpdateTimestampParams struct {
	CoursePhaseID         uuid.UUID `json:"course_phase_id"`
	CourseParticipationID uuid.UUID `json:"course_participation_id"`
}

func (q *Queries) StoreApplicationAnswerUpdateTimestamp(ctx context.Context, arg StoreApplicationAnswerUpdateTimestampParams) error {
	_, err := q.db.Exec(ctx, storeApplicationAnswerUpdateTimestamp, arg.CoursePhaseID, arg.CourseParticipationID)
	return err
}

const storeApplicationAssessmentUpdateTimestamp = `-- name: StoreApplicationAssessmentUpdateTimestamp :exec
UPDATE course_phase_participation
SET restricted_data = jsonb_set(
    COALESCE(restricted_data, '{}'), -- Ensure meta_data is not NULL
    '{assessment_last_modified}', -- Path to the key
    to_jsonb(NOW())::jsonb     -- Value to set
)
WHERE course_phase_id = $1
 AND course_participation_id = $2
`

type StoreApplicationAssessmentUpdateTimestampParams struct {
	CoursePhaseID         uuid.UUID `json:"course_phase_id"`
	CourseParticipationID uuid.UUID `json:"course_participation_id"`
}

func (q *Queries) StoreApplicationAssessmentUpdateTimestamp(ctx context.Context, arg StoreApplicationAssessmentUpdateTimestampParams) error {
	_, err := q.db.Exec(ctx, storeApplicationAssessmentUpdateTimestamp, arg.CoursePhaseID, arg.CourseParticipationID)
	return err
}

const updateApplicationAssessment = `-- name: UpdateApplicationAssessment :exec
INSERT INTO application_assessment (id, course_phase_id, course_participation_id, score)
VALUES (
    gen_random_uuid(),    
    $1,                   
    $2, 
    $3             
)
ON CONFLICT (course_phase_id, course_participation_id) 
DO UPDATE 
SET score = EXCLUDED.score
`

type UpdateApplicationAssessmentParams struct {
	CoursePhaseID         uuid.UUID   `json:"course_phase_id"`
	CourseParticipationID uuid.UUID   `json:"course_participation_id"`
	Score                 pgtype.Int4 `json:"score"`
}

func (q *Queries) UpdateApplicationAssessment(ctx context.Context, arg UpdateApplicationAssessmentParams) error {
	_, err := q.db.Exec(ctx, updateApplicationAssessment, arg.CoursePhaseID, arg.CourseParticipationID, arg.Score)
	return err
}

const updateApplicationQuestionMultiSelect = `-- name: UpdateApplicationQuestionMultiSelect :exec
UPDATE application_question_multi_select
SET
    title = COALESCE($2, title),
    description = COALESCE($3, description),
    placeholder = COALESCE($4, placeholder),
    error_message = COALESCE($5, error_message),
    is_required = COALESCE($6, is_required),
    min_select = COALESCE($7, min_select),
    max_select = COALESCE($8, max_select),
    options = COALESCE($9, options),
    order_num = COALESCE($10, order_num), 
    accessible_for_other_phases = COALESCE($11, accessible_for_other_phases),
    access_key = COALESCE($12, access_key)
WHERE id = $1
`

type UpdateApplicationQuestionMultiSelectParams struct {
	ID                       uuid.UUID   `json:"id"`
	Title                    pgtype.Text `json:"title"`
	Description              pgtype.Text `json:"description"`
	Placeholder              pgtype.Text `json:"placeholder"`
	ErrorMessage             pgtype.Text `json:"error_message"`
	IsRequired               pgtype.Bool `json:"is_required"`
	MinSelect                pgtype.Int4 `json:"min_select"`
	MaxSelect                pgtype.Int4 `json:"max_select"`
	Options                  []string    `json:"options"`
	OrderNum                 pgtype.Int4 `json:"order_num"`
	AccessibleForOtherPhases pgtype.Bool `json:"accessible_for_other_phases"`
	AccessKey                pgtype.Text `json:"access_key"`
}

func (q *Queries) UpdateApplicationQuestionMultiSelect(ctx context.Context, arg UpdateApplicationQuestionMultiSelectParams) error {
	_, err := q.db.Exec(ctx, updateApplicationQuestionMultiSelect,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Placeholder,
		arg.ErrorMessage,
		arg.IsRequired,
		arg.MinSelect,
		arg.MaxSelect,
		arg.Options,
		arg.OrderNum,
		arg.AccessibleForOtherPhases,
		arg.AccessKey,
	)
	return err
}

const updateApplicationQuestionText = `-- name: UpdateApplicationQuestionText :exec
UPDATE application_question_text
SET
    title = COALESCE($2, title),
    description = COALESCE($3, description),
    placeholder = COALESCE($4, placeholder),
    validation_regex = COALESCE($5, validation_regex),
    error_message = COALESCE($6, error_message),
    is_required = COALESCE($7, is_required),
    allowed_length = COALESCE($8, allowed_length),
    order_num = COALESCE($9, order_num),
    accessible_for_other_phases = COALESCE($10, accessible_for_other_phases),
    access_key = COALESCE($11, access_key)
WHERE id = $1
`

type UpdateApplicationQuestionTextParams struct {
	ID                       uuid.UUID   `json:"id"`
	Title                    pgtype.Text `json:"title"`
	Description              pgtype.Text `json:"description"`
	Placeholder              pgtype.Text `json:"placeholder"`
	ValidationRegex          pgtype.Text `json:"validation_regex"`
	ErrorMessage             pgtype.Text `json:"error_message"`
	IsRequired               pgtype.Bool `json:"is_required"`
	AllowedLength            pgtype.Int4 `json:"allowed_length"`
	OrderNum                 pgtype.Int4 `json:"order_num"`
	AccessibleForOtherPhases pgtype.Bool `json:"accessible_for_other_phases"`
	AccessKey                pgtype.Text `json:"access_key"`
}

func (q *Queries) UpdateApplicationQuestionText(ctx context.Context, arg UpdateApplicationQuestionTextParams) error {
	_, err := q.db.Exec(ctx, updateApplicationQuestionText,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Placeholder,
		arg.ValidationRegex,
		arg.ErrorMessage,
		arg.IsRequired,
		arg.AllowedLength,
		arg.OrderNum,
		arg.AccessibleForOtherPhases,
		arg.AccessKey,
	)
	return err
}

const updateExistingAdditionalScores = `-- name: UpdateExistingAdditionalScores :exec
UPDATE course_phase
SET restricted_data = restricted_data || $2
WHERE id = $1
`

type UpdateExistingAdditionalScoresParams struct {
	ID             uuid.UUID `json:"id"`
	RestrictedData []byte    `json:"restricted_data"`
}

func (q *Queries) UpdateExistingAdditionalScores(ctx context.Context, arg UpdateExistingAdditionalScoresParams) error {
	_, err := q.db.Exec(ctx, updateExistingAdditionalScores, arg.ID, arg.RestrictedData)
	return err
}
