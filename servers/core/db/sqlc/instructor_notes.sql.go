// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: instructor_notes.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createNote = `-- name: CreateNote :one
INSERT INTO note (id, for_student, author, date_created, date_deleted, deleted_by)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, for_student, author, date_created, date_deleted, deleted_by
`

type CreateNoteParams struct {
	ID          uuid.UUID   `json:"id"`
	ForStudent  uuid.UUID   `json:"for_student"`
	Author      uuid.UUID   `json:"author"`
	DateCreated pgtype.Date `json:"date_created"`
	DateDeleted pgtype.Date `json:"date_deleted"`
	DeletedBy   pgtype.UUID `json:"deleted_by"`
}

func (q *Queries) CreateNote(ctx context.Context, arg CreateNoteParams) (Note, error) {
	row := q.db.QueryRow(ctx, createNote,
		arg.ID,
		arg.ForStudent,
		arg.Author,
		arg.DateCreated,
		arg.DateDeleted,
		arg.DeletedBy,
	)
	var i Note
	err := row.Scan(
		&i.ID,
		&i.ForStudent,
		&i.Author,
		&i.DateCreated,
		&i.DateDeleted,
		&i.DeletedBy,
	)
	return i, err
}

const createNoteVersion = `-- name: CreateNoteVersion :one
INSERT INTO note_version ( id, content, date_created, version_number, for_note )
VALUES ($1, $2, $3, $4, $5)
RETURNING id, content, date_created, version_number, for_note
`

type CreateNoteVersionParams struct {
	ID            uuid.UUID   `json:"id"`
	Content       string      `json:"content"`
	DateCreated   pgtype.Date `json:"date_created"`
	VersionNumber int32       `json:"version_number"`
	ForNote       uuid.UUID   `json:"for_note"`
}

func (q *Queries) CreateNoteVersion(ctx context.Context, arg CreateNoteVersionParams) (NoteVersion, error) {
	row := q.db.QueryRow(ctx, createNoteVersion,
		arg.ID,
		arg.Content,
		arg.DateCreated,
		arg.VersionNumber,
		arg.ForNote,
	)
	var i NoteVersion
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.DateCreated,
		&i.VersionNumber,
		&i.ForNote,
	)
	return i, err
}

const getAllStudentNotes = `-- name: GetAllStudentNotes :many
SELECT id, author, for_student, date_created, date_deleted, deleted_by, versions FROM note_with_versions
`

func (q *Queries) GetAllStudentNotes(ctx context.Context) ([]NoteWithVersion, error) {
	rows, err := q.db.Query(ctx, getAllStudentNotes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NoteWithVersion
	for rows.Next() {
		var i NoteWithVersion
		if err := rows.Scan(
			&i.ID,
			&i.Author,
			&i.ForStudent,
			&i.DateCreated,
			&i.DateDeleted,
			&i.DeletedBy,
			&i.Versions,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllStudentNotesGroupByStudent = `-- name: GetAllStudentNotesGroupByStudent :many
SELECT
  s.id,
  jsonb_agg(
    jsonb_build_object(
      'id', n.id,
      'author', n.author,
      'date_created', n.date_created,
      'date_deleted', n.date_deleted,
      'deleted_by', n.deleted_by,
      'versions', n.versions
    )
  ) AS notes
FROM student s
LEFT JOIN note_with_versions n
  ON n.for_student = s.id
GROUP BY s.id
`

type GetAllStudentNotesGroupByStudentRow struct {
	ID    uuid.UUID `json:"id"`
	Notes []byte    `json:"notes"`
}

func (q *Queries) GetAllStudentNotesGroupByStudent(ctx context.Context) ([]GetAllStudentNotesGroupByStudentRow, error) {
	rows, err := q.db.Query(ctx, getAllStudentNotesGroupByStudent)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllStudentNotesGroupByStudentRow
	for rows.Next() {
		var i GetAllStudentNotesGroupByStudentRow
		if err := rows.Scan(&i.ID, &i.Notes); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestNoteVersionForNoteId = `-- name: GetLatestNoteVersionForNoteId :one
SELECT nv.version_number
FROM note_version nv
WHERE nv.for_note = $1
ORDER BY nv.version_number DESC
LIMIT 1
`

func (q *Queries) GetLatestNoteVersionForNoteId(ctx context.Context, forNote uuid.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, getLatestNoteVersionForNoteId, forNote)
	var version_number int32
	err := row.Scan(&version_number)
	return version_number, err
}

const getSingleStudentNoteByID = `-- name: GetSingleStudentNoteByID :one
SELECT id, for_student, author, date_created, date_deleted, deleted_by FROM note WHERE id = $1 LIMIT 1
`

func (q *Queries) GetSingleStudentNoteByID(ctx context.Context, id uuid.UUID) (Note, error) {
	row := q.db.QueryRow(ctx, getSingleStudentNoteByID, id)
	var i Note
	err := row.Scan(
		&i.ID,
		&i.ForStudent,
		&i.Author,
		&i.DateCreated,
		&i.DateDeleted,
		&i.DeletedBy,
	)
	return i, err
}

const getStudentNotesForStudent = `-- name: GetStudentNotesForStudent :many
SELECT id, author, for_student, date_created, date_deleted, deleted_by, versions FROM note_with_versions WHERE for_student = $1
`

func (q *Queries) GetStudentNotesForStudent(ctx context.Context, forStudent uuid.UUID) ([]NoteWithVersion, error) {
	rows, err := q.db.Query(ctx, getStudentNotesForStudent, forStudent)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NoteWithVersion
	for rows.Next() {
		var i NoteWithVersion
		if err := rows.Scan(
			&i.ID,
			&i.Author,
			&i.ForStudent,
			&i.DateCreated,
			&i.DateDeleted,
			&i.DeletedBy,
			&i.Versions,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
