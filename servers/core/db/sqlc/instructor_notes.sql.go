// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: instructor_notes.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addTagToNote = `-- name: AddTagToNote :exec
INSERT INTO note_tag_relation (note_id, tag_id) VALUES ($1, $2) ON CONFLICT DO NOTHING
`

type AddTagToNoteParams struct {
	NoteID uuid.UUID `json:"note_id"`
	TagID  uuid.UUID `json:"tag_id"`
}

func (q *Queries) AddTagToNote(ctx context.Context, arg AddTagToNoteParams) error {
	_, err := q.db.Exec(ctx, addTagToNote, arg.NoteID, arg.TagID)
	return err
}

const createNote = `-- name: CreateNote :one
INSERT INTO note (id, for_student, author, author_name, author_email, date_created, date_deleted, deleted_by)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, for_student, author, author_name, author_email, date_created, date_deleted, deleted_by
`

type CreateNoteParams struct {
	ID          uuid.UUID          `json:"id"`
	ForStudent  uuid.UUID          `json:"for_student"`
	Author      uuid.UUID          `json:"author"`
	AuthorName  string             `json:"author_name"`
	AuthorEmail string             `json:"author_email"`
	DateCreated pgtype.Timestamptz `json:"date_created"`
	DateDeleted pgtype.Timestamptz `json:"date_deleted"`
	DeletedBy   pgtype.UUID        `json:"deleted_by"`
}

func (q *Queries) CreateNote(ctx context.Context, arg CreateNoteParams) (Note, error) {
	row := q.db.QueryRow(ctx, createNote,
		arg.ID,
		arg.ForStudent,
		arg.Author,
		arg.AuthorName,
		arg.AuthorEmail,
		arg.DateCreated,
		arg.DateDeleted,
		arg.DeletedBy,
	)
	var i Note
	err := row.Scan(
		&i.ID,
		&i.ForStudent,
		&i.Author,
		&i.AuthorName,
		&i.AuthorEmail,
		&i.DateCreated,
		&i.DateDeleted,
		&i.DeletedBy,
	)
	return i, err
}

const createNoteVersion = `-- name: CreateNoteVersion :one
INSERT INTO note_version ( id, content, date_created, version_number, for_note )
VALUES ($1, $2, $3, $4, $5)
RETURNING id, content, date_created, version_number, for_note
`

type CreateNoteVersionParams struct {
	ID            uuid.UUID          `json:"id"`
	Content       string             `json:"content"`
	DateCreated   pgtype.Timestamptz `json:"date_created"`
	VersionNumber int32              `json:"version_number"`
	ForNote       uuid.UUID          `json:"for_note"`
}

func (q *Queries) CreateNoteVersion(ctx context.Context, arg CreateNoteVersionParams) (NoteVersion, error) {
	row := q.db.QueryRow(ctx, createNoteVersion,
		arg.ID,
		arg.Content,
		arg.DateCreated,
		arg.VersionNumber,
		arg.ForNote,
	)
	var i NoteVersion
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.DateCreated,
		&i.VersionNumber,
		&i.ForNote,
	)
	return i, err
}

const createTag = `-- name: CreateTag :one
INSERT INTO note_tag (id, name, color) VALUES ($1, $2, $3) RETURNING id, name, color
`

type CreateTagParams struct {
	ID    uuid.UUID    `json:"id"`
	Name  string       `json:"name"`
	Color NoteTagColor `json:"color"`
}

func (q *Queries) CreateTag(ctx context.Context, arg CreateTagParams) (NoteTag, error) {
	row := q.db.QueryRow(ctx, createTag, arg.ID, arg.Name, arg.Color)
	var i NoteTag
	err := row.Scan(&i.ID, &i.Name, &i.Color)
	return i, err
}

const deleteNote = `-- name: DeleteNote :one
UPDATE note
SET date_deleted = now(), deleted_by = $2
WHERE id = $1
AND date_deleted IS NULL
RETURNING id, for_student, author, author_name, author_email, date_created, date_deleted, deleted_by
`

type DeleteNoteParams struct {
	ID        uuid.UUID   `json:"id"`
	DeletedBy pgtype.UUID `json:"deleted_by"`
}

func (q *Queries) DeleteNote(ctx context.Context, arg DeleteNoteParams) (Note, error) {
	row := q.db.QueryRow(ctx, deleteNote, arg.ID, arg.DeletedBy)
	var i Note
	err := row.Scan(
		&i.ID,
		&i.ForStudent,
		&i.Author,
		&i.AuthorName,
		&i.AuthorEmail,
		&i.DateCreated,
		&i.DateDeleted,
		&i.DeletedBy,
	)
	return i, err
}

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM note_tag WHERE id = $1
`

func (q *Queries) DeleteTag(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteTag, id)
	return err
}

const getAllStudentNotes = `-- name: GetAllStudentNotes :many
SELECT id, author, author_name, author_email, for_student, date_created, date_deleted, deleted_by, versions, tags FROM note_with_versions ORDER BY date_created DESC
`

func (q *Queries) GetAllStudentNotes(ctx context.Context) ([]NoteWithVersion, error) {
	rows, err := q.db.Query(ctx, getAllStudentNotes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NoteWithVersion
	for rows.Next() {
		var i NoteWithVersion
		if err := rows.Scan(
			&i.ID,
			&i.Author,
			&i.AuthorName,
			&i.AuthorEmail,
			&i.ForStudent,
			&i.DateCreated,
			&i.DateDeleted,
			&i.DeletedBy,
			&i.Versions,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTags = `-- name: GetAllTags :many
SELECT id, name, color FROM note_tag ORDER BY name ASC
`

func (q *Queries) GetAllTags(ctx context.Context) ([]NoteTag, error) {
	rows, err := q.db.Query(ctx, getAllTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NoteTag
	for rows.Next() {
		var i NoteTag
		if err := rows.Scan(&i.ID, &i.Name, &i.Color); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestNoteVersionForNoteId = `-- name: GetLatestNoteVersionForNoteId :one
SELECT nv.version_number
FROM note_version nv
WHERE nv.for_note = $1
ORDER BY nv.version_number DESC
LIMIT 1
`

func (q *Queries) GetLatestNoteVersionForNoteId(ctx context.Context, forNote uuid.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, getLatestNoteVersionForNoteId, forNote)
	var version_number int32
	err := row.Scan(&version_number)
	return version_number, err
}

const getSingleNoteWithVersionsByID = `-- name: GetSingleNoteWithVersionsByID :one
SELECT id, author, author_name, author_email, for_student, date_created, date_deleted, deleted_by, versions, tags FROM note_with_versions WHERE id = $1 LIMIT 1
`

func (q *Queries) GetSingleNoteWithVersionsByID(ctx context.Context, id uuid.UUID) (NoteWithVersion, error) {
	row := q.db.QueryRow(ctx, getSingleNoteWithVersionsByID, id)
	var i NoteWithVersion
	err := row.Scan(
		&i.ID,
		&i.Author,
		&i.AuthorName,
		&i.AuthorEmail,
		&i.ForStudent,
		&i.DateCreated,
		&i.DateDeleted,
		&i.DeletedBy,
		&i.Versions,
		&i.Tags,
	)
	return i, err
}

const getSingleStudentNoteByID = `-- name: GetSingleStudentNoteByID :one
SELECT id, for_student, author, author_name, author_email, date_created, date_deleted, deleted_by FROM note WHERE id = $1 LIMIT 1
`

func (q *Queries) GetSingleStudentNoteByID(ctx context.Context, id uuid.UUID) (Note, error) {
	row := q.db.QueryRow(ctx, getSingleStudentNoteByID, id)
	var i Note
	err := row.Scan(
		&i.ID,
		&i.ForStudent,
		&i.Author,
		&i.AuthorName,
		&i.AuthorEmail,
		&i.DateCreated,
		&i.DateDeleted,
		&i.DeletedBy,
	)
	return i, err
}

const getStudentNotesForStudent = `-- name: GetStudentNotesForStudent :many
SELECT id, author, author_name, author_email, for_student, date_created, date_deleted, deleted_by, versions, tags FROM note_with_versions WHERE for_student = $1 ORDER BY date_created ASC
`

func (q *Queries) GetStudentNotesForStudent(ctx context.Context, forStudent uuid.UUID) ([]NoteWithVersion, error) {
	rows, err := q.db.Query(ctx, getStudentNotesForStudent, forStudent)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NoteWithVersion
	for rows.Next() {
		var i NoteWithVersion
		if err := rows.Scan(
			&i.ID,
			&i.Author,
			&i.AuthorName,
			&i.AuthorEmail,
			&i.ForStudent,
			&i.DateCreated,
			&i.DateDeleted,
			&i.DeletedBy,
			&i.Versions,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagByID = `-- name: GetTagByID :one
SELECT id, name, color FROM note_tag WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTagByID(ctx context.Context, id uuid.UUID) (NoteTag, error) {
	row := q.db.QueryRow(ctx, getTagByID, id)
	var i NoteTag
	err := row.Scan(&i.ID, &i.Name, &i.Color)
	return i, err
}

const getTagsForNote = `-- name: GetTagsForNote :many
SELECT nt.id, nt.name, nt.color FROM note_tag nt
JOIN note_tag_relation ntr ON ntr.tag_id = nt.id
WHERE ntr.note_id = $1
ORDER BY nt.name ASC
`

func (q *Queries) GetTagsForNote(ctx context.Context, noteID uuid.UUID) ([]NoteTag, error) {
	rows, err := q.db.Query(ctx, getTagsForNote, noteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NoteTag
	for rows.Next() {
		var i NoteTag
		if err := rows.Scan(&i.ID, &i.Name, &i.Color); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAllTagsFromNote = `-- name: RemoveAllTagsFromNote :exec
DELETE FROM note_tag_relation WHERE note_id = $1
`

func (q *Queries) RemoveAllTagsFromNote(ctx context.Context, noteID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeAllTagsFromNote, noteID)
	return err
}

const removeTagFromNote = `-- name: RemoveTagFromNote :exec
DELETE FROM note_tag_relation WHERE note_id = $1 AND tag_id = $2
`

type RemoveTagFromNoteParams struct {
	NoteID uuid.UUID `json:"note_id"`
	TagID  uuid.UUID `json:"tag_id"`
}

func (q *Queries) RemoveTagFromNote(ctx context.Context, arg RemoveTagFromNoteParams) error {
	_, err := q.db.Exec(ctx, removeTagFromNote, arg.NoteID, arg.TagID)
	return err
}

const updateTag = `-- name: UpdateTag :one
UPDATE note_tag SET name = $2, color = $3 WHERE id = $1 RETURNING id, name, color
`

type UpdateTagParams struct {
	ID    uuid.UUID    `json:"id"`
	Name  string       `json:"name"`
	Color NoteTagColor `json:"color"`
}

func (q *Queries) UpdateTag(ctx context.Context, arg UpdateTagParams) (NoteTag, error) {
	row := q.db.QueryRow(ctx, updateTag, arg.ID, arg.Name, arg.Color)
	var i NoteTag
	err := row.Scan(&i.ID, &i.Name, &i.Color)
	return i, err
}
