// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: file.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countFilesByUploader = `-- name: CountFilesByUploader :one
SELECT COUNT(*) FROM files
WHERE uploaded_by_user_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountFilesByUploader(ctx context.Context, uploadedByUserID string) (int64, error) {
	row := q.db.QueryRow(ctx, countFilesByUploader, uploadedByUserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createFile = `-- name: CreateFile :one
INSERT INTO files (
    filename,
    original_filename,
    content_type,
    size_bytes,
    storage_key,
    storage_provider,
    uploaded_by_user_id,
    uploaded_by_email,
    course_phase_id,
    description,
    tags
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, filename, original_filename, content_type, size_bytes, storage_key, storage_provider, uploaded_by_user_id, uploaded_by_email, course_phase_id, description, tags, created_at, updated_at, deleted_at
`

type CreateFileParams struct {
	Filename         string      `json:"filename"`
	OriginalFilename string      `json:"original_filename"`
	ContentType      string      `json:"content_type"`
	SizeBytes        int64       `json:"size_bytes"`
	StorageKey       string      `json:"storage_key"`
	StorageProvider  string      `json:"storage_provider"`
	UploadedByUserID string      `json:"uploaded_by_user_id"`
	UploadedByEmail  pgtype.Text `json:"uploaded_by_email"`
	CoursePhaseID    pgtype.UUID `json:"course_phase_id"`
	Description      pgtype.Text `json:"description"`
	Tags             []string    `json:"tags"`
}

func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) (File, error) {
	row := q.db.QueryRow(ctx, createFile,
		arg.Filename,
		arg.OriginalFilename,
		arg.ContentType,
		arg.SizeBytes,
		arg.StorageKey,
		arg.StorageProvider,
		arg.UploadedByUserID,
		arg.UploadedByEmail,
		arg.CoursePhaseID,
		arg.Description,
		arg.Tags,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.OriginalFilename,
		&i.ContentType,
		&i.SizeBytes,
		&i.StorageKey,
		&i.StorageProvider,
		&i.UploadedByUserID,
		&i.UploadedByEmail,
		&i.CoursePhaseID,
		&i.Description,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAllFiles = `-- name: GetAllFiles :many
SELECT id, filename, original_filename, content_type, size_bytes, storage_key, storage_provider, uploaded_by_user_id, uploaded_by_email, course_phase_id, description, tags, created_at, updated_at, deleted_at FROM files
WHERE deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type GetAllFilesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllFiles(ctx context.Context, arg GetAllFilesParams) ([]File, error) {
	rows, err := q.db.Query(ctx, getAllFiles, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.OriginalFilename,
			&i.ContentType,
			&i.SizeBytes,
			&i.StorageKey,
			&i.StorageProvider,
			&i.UploadedByUserID,
			&i.UploadedByEmail,
			&i.CoursePhaseID,
			&i.Description,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFileByID = `-- name: GetFileByID :one
SELECT id, filename, original_filename, content_type, size_bytes, storage_key, storage_provider, uploaded_by_user_id, uploaded_by_email, course_phase_id, description, tags, created_at, updated_at, deleted_at FROM files
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetFileByID(ctx context.Context, id uuid.UUID) (File, error) {
	row := q.db.QueryRow(ctx, getFileByID, id)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.OriginalFilename,
		&i.ContentType,
		&i.SizeBytes,
		&i.StorageKey,
		&i.StorageProvider,
		&i.UploadedByUserID,
		&i.UploadedByEmail,
		&i.CoursePhaseID,
		&i.Description,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getFileByStorageKey = `-- name: GetFileByStorageKey :one
SELECT id, filename, original_filename, content_type, size_bytes, storage_key, storage_provider, uploaded_by_user_id, uploaded_by_email, course_phase_id, description, tags, created_at, updated_at, deleted_at FROM files
WHERE storage_key = $1 AND deleted_at IS NULL
`

func (q *Queries) GetFileByStorageKey(ctx context.Context, storageKey string) (File, error) {
	row := q.db.QueryRow(ctx, getFileByStorageKey, storageKey)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.OriginalFilename,
		&i.ContentType,
		&i.SizeBytes,
		&i.StorageKey,
		&i.StorageProvider,
		&i.UploadedByUserID,
		&i.UploadedByEmail,
		&i.CoursePhaseID,
		&i.Description,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getFilesByCoursePhaseID = `-- name: GetFilesByCoursePhaseID :many
SELECT id, filename, original_filename, content_type, size_bytes, storage_key, storage_provider, uploaded_by_user_id, uploaded_by_email, course_phase_id, description, tags, created_at, updated_at, deleted_at FROM files
WHERE course_phase_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) GetFilesByCoursePhaseID(ctx context.Context, coursePhaseID pgtype.UUID) ([]File, error) {
	rows, err := q.db.Query(ctx, getFilesByCoursePhaseID, coursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.OriginalFilename,
			&i.ContentType,
			&i.SizeBytes,
			&i.StorageKey,
			&i.StorageProvider,
			&i.UploadedByUserID,
			&i.UploadedByEmail,
			&i.CoursePhaseID,
			&i.Description,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilesByTags = `-- name: GetFilesByTags :many
SELECT id, filename, original_filename, content_type, size_bytes, storage_key, storage_provider, uploaded_by_user_id, uploaded_by_email, course_phase_id, description, tags, created_at, updated_at, deleted_at FROM files
WHERE tags && $1::VARCHAR[] AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetFilesByTagsParams struct {
	Column1 []string `json:"column_1"`
	Limit   int32    `json:"limit"`
	Offset  int32    `json:"offset"`
}

func (q *Queries) GetFilesByTags(ctx context.Context, arg GetFilesByTagsParams) ([]File, error) {
	rows, err := q.db.Query(ctx, getFilesByTags, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.OriginalFilename,
			&i.ContentType,
			&i.SizeBytes,
			&i.StorageKey,
			&i.StorageProvider,
			&i.UploadedByUserID,
			&i.UploadedByEmail,
			&i.CoursePhaseID,
			&i.Description,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilesByUploader = `-- name: GetFilesByUploader :many
SELECT id, filename, original_filename, content_type, size_bytes, storage_key, storage_provider, uploaded_by_user_id, uploaded_by_email, course_phase_id, description, tags, created_at, updated_at, deleted_at FROM files
WHERE uploaded_by_user_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetFilesByUploaderParams struct {
	UploadedByUserID string `json:"uploaded_by_user_id"`
	Limit            int32  `json:"limit"`
	Offset           int32  `json:"offset"`
}

func (q *Queries) GetFilesByUploader(ctx context.Context, arg GetFilesByUploaderParams) ([]File, error) {
	rows, err := q.db.Query(ctx, getFilesByUploader, arg.UploadedByUserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.OriginalFilename,
			&i.ContentType,
			&i.SizeBytes,
			&i.StorageKey,
			&i.StorageProvider,
			&i.UploadedByUserID,
			&i.UploadedByEmail,
			&i.CoursePhaseID,
			&i.Description,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalFileSizeByUploader = `-- name: GetTotalFileSizeByUploader :one
SELECT COALESCE(SUM(size_bytes), 0) as total_size
FROM files
WHERE uploaded_by_user_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetTotalFileSizeByUploader(ctx context.Context, uploadedByUserID string) (interface{}, error) {
	row := q.db.QueryRow(ctx, getTotalFileSizeByUploader, uploadedByUserID)
	var total_size interface{}
	err := row.Scan(&total_size)
	return total_size, err
}

const hardDeleteFile = `-- name: HardDeleteFile :exec
DELETE FROM files
WHERE id = $1
`

func (q *Queries) HardDeleteFile(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, hardDeleteFile, id)
	return err
}

const softDeleteFile = `-- name: SoftDeleteFile :exec
UPDATE files
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) SoftDeleteFile(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteFile, id)
	return err
}

const updateFileMetadata = `-- name: UpdateFileMetadata :one
UPDATE files
SET 
    description = COALESCE($2, description),
    tags = COALESCE($3, tags),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, filename, original_filename, content_type, size_bytes, storage_key, storage_provider, uploaded_by_user_id, uploaded_by_email, course_phase_id, description, tags, created_at, updated_at, deleted_at
`

type UpdateFileMetadataParams struct {
	ID          uuid.UUID   `json:"id"`
	Description pgtype.Text `json:"description"`
	Tags        []string    `json:"tags"`
}

func (q *Queries) UpdateFileMetadata(ctx context.Context, arg UpdateFileMetadataParams) (File, error) {
	row := q.db.QueryRow(ctx, updateFileMetadata, arg.ID, arg.Description, arg.Tags)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.OriginalFilename,
		&i.ContentType,
		&i.SizeBytes,
		&i.StorageKey,
		&i.StorageProvider,
		&i.UploadedByUserID,
		&i.UploadedByEmail,
		&i.CoursePhaseID,
		&i.Description,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
