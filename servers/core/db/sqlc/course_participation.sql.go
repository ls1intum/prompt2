// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: course_participation.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createCourseParticipation = `-- name: CreateCourseParticipation :one
INSERT INTO course_participation (id, course_id, student_id)
VALUES ($1, $2, $3)
RETURNING id, course_id, student_id
`

type CreateCourseParticipationParams struct {
	ID        uuid.UUID `json:"id"`
	CourseID  uuid.UUID `json:"course_id"`
	StudentID uuid.UUID `json:"student_id"`
}

func (q *Queries) CreateCourseParticipation(ctx context.Context, arg CreateCourseParticipationParams) (CourseParticipation, error) {
	row := q.db.QueryRow(ctx, createCourseParticipation, arg.ID, arg.CourseID, arg.StudentID)
	var i CourseParticipation
	err := row.Scan(&i.ID, &i.CourseID, &i.StudentID)
	return i, err
}

const getAllCourseParticipationsForCourse = `-- name: GetAllCourseParticipationsForCourse :many
SELECT id, course_id, student_id FROM course_participation
WHERE course_id = $1
`

func (q *Queries) GetAllCourseParticipationsForCourse(ctx context.Context, courseID uuid.UUID) ([]CourseParticipation, error) {
	rows, err := q.db.Query(ctx, getAllCourseParticipationsForCourse, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CourseParticipation
	for rows.Next() {
		var i CourseParticipation
		if err := rows.Scan(&i.ID, &i.CourseID, &i.StudentID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCourseParticipationsForStudent = `-- name: GetAllCourseParticipationsForStudent :many
SELECT id, course_id, student_id FROM course_participation
WHERE student_id = $1
`

func (q *Queries) GetAllCourseParticipationsForStudent(ctx context.Context, studentID uuid.UUID) ([]CourseParticipation, error) {
	rows, err := q.db.Query(ctx, getAllCourseParticipationsForStudent, studentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CourseParticipation
	for rows.Next() {
		var i CourseParticipation
		if err := rows.Scan(&i.ID, &i.CourseID, &i.StudentID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCourseParticipation = `-- name: GetCourseParticipation :one
SELECT id, course_id, student_id FROM course_participation
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCourseParticipation(ctx context.Context, id uuid.UUID) (CourseParticipation, error) {
	row := q.db.QueryRow(ctx, getCourseParticipation, id)
	var i CourseParticipation
	err := row.Scan(&i.ID, &i.CourseID, &i.StudentID)
	return i, err
}

const getCourseParticipationByCourseIDAndMatriculation = `-- name: GetCourseParticipationByCourseIDAndMatriculation :one
WITH existing_phases AS (
    SELECT cpp.course_phase_id
    FROM course_participation cp
    JOIN course_phase_participation cpp 
        ON cpp.course_participation_id = cp.id
    JOIN student s 
        ON s.id = cp.student_id
    WHERE cp.course_id = $1 
      AND s.matriculation_number = $2 
      AND s.university_login = $3
),
passed_phases AS (
    SELECT cpp.course_phase_id
    FROM course_participation cp
    JOIN course_phase_participation cpp 
        ON cpp.course_participation_id = cp.id
    JOIN student s 
        ON s.id = cp.student_id
    WHERE cp.course_id = $1 
      AND s.matriculation_number = $2 
      AND s.university_login = $3
      AND cpp.pass_status = 'passed'
),
next_phases AS (
    SELECT cpg.to_course_phase_id
    FROM course_phase_graph cpg
    JOIN passed_phases pp
        ON cpg.from_course_phase_id = pp.course_phase_id
    WHERE cpg.to_course_phase_id NOT IN (
        SELECT course_phase_id FROM existing_phases
    )
)
SELECT 
    cp.id, 
    cp.course_id, 
    cp.student_id, 
    ARRAY_AGG(DISTINCT cp_ph.course_phase_id)::uuid[] AS active_course_phases
FROM 
    course_participation cp
JOIN 
    student s 
        ON s.id = cp.student_id
LEFT JOIN (
    -- Combine existing and eligible next phases
    SELECT course_phase_id FROM existing_phases
    UNION
    SELECT to_course_phase_id AS course_phase_id FROM next_phases
) AS cp_ph 
    ON TRUE
WHERE 
    cp.course_id = $1 
    AND s.matriculation_number = $2 
    AND s.university_login = $3
GROUP BY 
    cp.id, 
    cp.course_id, 
    cp.student_id
`

type GetCourseParticipationByCourseIDAndMatriculationParams struct {
	CourseID            uuid.UUID   `json:"course_id"`
	MatriculationNumber pgtype.Text `json:"matriculation_number"`
	UniversityLogin     pgtype.Text `json:"university_login"`
}

type GetCourseParticipationByCourseIDAndMatriculationRow struct {
	ID                 uuid.UUID   `json:"id"`
	CourseID           uuid.UUID   `json:"course_id"`
	StudentID          uuid.UUID   `json:"student_id"`
	ActiveCoursePhases []uuid.UUID `json:"active_course_phases"`
}

func (q *Queries) GetCourseParticipationByCourseIDAndMatriculation(ctx context.Context, arg GetCourseParticipationByCourseIDAndMatriculationParams) (GetCourseParticipationByCourseIDAndMatriculationRow, error) {
	row := q.db.QueryRow(ctx, getCourseParticipationByCourseIDAndMatriculation, arg.CourseID, arg.MatriculationNumber, arg.UniversityLogin)
	var i GetCourseParticipationByCourseIDAndMatriculationRow
	err := row.Scan(
		&i.ID,
		&i.CourseID,
		&i.StudentID,
		&i.ActiveCoursePhases,
	)
	return i, err
}

const getCourseParticipationByStudentAndCourseID = `-- name: GetCourseParticipationByStudentAndCourseID :one
SELECT id, course_id, student_id FROM course_participation
WHERE student_id = $1 AND course_id = $2 LIMIT 1
`

type GetCourseParticipationByStudentAndCourseIDParams struct {
	StudentID uuid.UUID `json:"student_id"`
	CourseID  uuid.UUID `json:"course_id"`
}

func (q *Queries) GetCourseParticipationByStudentAndCourseID(ctx context.Context, arg GetCourseParticipationByStudentAndCourseIDParams) (CourseParticipation, error) {
	row := q.db.QueryRow(ctx, getCourseParticipationByStudentAndCourseID, arg.StudentID, arg.CourseID)
	var i CourseParticipation
	err := row.Scan(&i.ID, &i.CourseID, &i.StudentID)
	return i, err
}

const getCourseParticipationByStudentAndCoursePhaseID = `-- name: GetCourseParticipationByStudentAndCoursePhaseID :one
SELECT course_participation.id, course_participation.course_id, course_participation.student_id 
FROM course_participation
JOIN course_phase cp 
    ON cp.course_id = course_participation.course_id
WHERE 
  course_participation.student_id = $1 
  AND cp.id = $2::uuid 
LIMIT 1
`

type GetCourseParticipationByStudentAndCoursePhaseIDParams struct {
	StudentID     uuid.UUID `json:"student_id"`
	CoursePhaseID uuid.UUID `json:"course_phase_id"`
}

func (q *Queries) GetCourseParticipationByStudentAndCoursePhaseID(ctx context.Context, arg GetCourseParticipationByStudentAndCoursePhaseIDParams) (CourseParticipation, error) {
	row := q.db.QueryRow(ctx, getCourseParticipationByStudentAndCoursePhaseID, arg.StudentID, arg.CoursePhaseID)
	var i CourseParticipation
	err := row.Scan(&i.ID, &i.CourseID, &i.StudentID)
	return i, err
}

const isStudentInCoursePhase = `-- name: IsStudentInCoursePhase :one
SELECT 
  cp.id AS course_participation_id,
  CASE 
    WHEN EXISTS (
      SELECT 1
      FROM course_phase_participation cpp
      WHERE cpp.course_participation_id = cp.id
        AND cpp.course_phase_id = $1::uuid
    )
    OR EXISTS (
      SELECT 1
      FROM course_phase_graph cpg
      JOIN course_phase_participation cpp_prev 
        ON cpp_prev.course_phase_id = cpg.from_course_phase_id
      WHERE cpg.to_course_phase_id = $1::uuid
        AND cpp_prev.course_participation_id = cp.id
        AND cpp_prev.pass_status = 'passed'
    )
    THEN true
    ELSE false
  END AS is_in_phase
FROM student s
JOIN course_participation cp 
  ON cp.student_id = s.id
JOIN course_phase cphase
  ON cphase.course_id = cp.course_id
WHERE cphase.id = $1::uuid
  AND s.matriculation_number = $2::text
  AND s.university_login = $3::text
`

type IsStudentInCoursePhaseParams struct {
	CoursePhaseID       uuid.UUID `json:"course_phase_id"`
	MatriculationNumber string    `json:"matriculation_number"`
	UniversityLogin     string    `json:"university_login"`
}

type IsStudentInCoursePhaseRow struct {
	CourseParticipationID uuid.UUID `json:"course_participation_id"`
	IsInPhase             bool      `json:"is_in_phase"`
}

func (q *Queries) IsStudentInCoursePhase(ctx context.Context, arg IsStudentInCoursePhaseParams) (IsStudentInCoursePhaseRow, error) {
	row := q.db.QueryRow(ctx, isStudentInCoursePhase, arg.CoursePhaseID, arg.MatriculationNumber, arg.UniversityLogin)
	var i IsStudentInCoursePhaseRow
	err := row.Scan(&i.CourseParticipationID, &i.IsInPhase)
	return i, err
}
