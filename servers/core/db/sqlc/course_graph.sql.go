// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: course_graph.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createCourseGraphConnection = `-- name: CreateCourseGraphConnection :exec
INSERT INTO course_phase_graph (from_course_phase_id, to_course_phase_id)
VALUES ($1, $2)
`

type CreateCourseGraphConnectionParams struct {
	FromCoursePhaseID uuid.UUID `json:"from_course_phase_id"`
	ToCoursePhaseID   uuid.UUID `json:"to_course_phase_id"`
}

func (q *Queries) CreateCourseGraphConnection(ctx context.Context, arg CreateCourseGraphConnectionParams) error {
	_, err := q.db.Exec(ctx, createCourseGraphConnection, arg.FromCoursePhaseID, arg.ToCoursePhaseID)
	return err
}

const deleteCourseGraph = `-- name: DeleteCourseGraph :exec
DELETE FROM course_phase_graph
WHERE from_course_phase_id IN 
    (SELECT id FROM course_phase WHERE course_id = $1)
`

func (q *Queries) DeleteCourseGraph(ctx context.Context, courseID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCourseGraph, courseID)
	return err
}

const getCoursePhaseGraph = `-- name: GetCoursePhaseGraph :many
SELECT cpg.from_course_phase_id, cpg.to_course_phase_id
FROM course_phase_graph cpg
JOIN course_phase cp
  ON cpg.from_course_phase_id = cp.id
WHERE cp.course_id = $1
`

func (q *Queries) GetCoursePhaseGraph(ctx context.Context, courseID uuid.UUID) ([]CoursePhaseGraph, error) {
	rows, err := q.db.Query(ctx, getCoursePhaseGraph, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoursePhaseGraph
	for rows.Next() {
		var i CoursePhaseGraph
		if err := rows.Scan(&i.FromCoursePhaseID, &i.ToCoursePhaseID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoursePhaseSequence = `-- name: GetCoursePhaseSequence :many
WITH RECURSIVE phase_sequence AS (
    SELECT cp.id, cp.course_id, cp.name, cp.is_initial_phase, cp.course_phase_type_id, 1 AS sequence_order
    FROM course_phase cp
    WHERE cp.course_id = $1 AND cp.is_initial_phase = true

    UNION ALL

    SELECT cp.id, cp.course_id, cp.name, cp.is_initial_phase, cp.course_phase_type_id, ps.sequence_order + 1 AS sequence_order
    FROM course_phase cp
    INNER JOIN course_phase_graph g ON g.to_course_phase_id = cp.id
    INNER JOIN phase_sequence ps ON g.from_course_phase_id = ps.id
)
SELECT ps.id, ps.course_id, ps.name, ps.is_initial_phase, ps.course_phase_type_id, ps.sequence_order, cpt.name AS course_phase_type_name
FROM phase_sequence ps
INNER JOIN course_phase_type cpt ON ps.course_phase_type_id = cpt.id
ORDER BY ps.sequence_order
`

type GetCoursePhaseSequenceRow struct {
	ID                  uuid.UUID   `json:"id"`
	CourseID            uuid.UUID   `json:"course_id"`
	Name                pgtype.Text `json:"name"`
	IsInitialPhase      bool        `json:"is_initial_phase"`
	CoursePhaseTypeID   uuid.UUID   `json:"course_phase_type_id"`
	SequenceOrder       int32       `json:"sequence_order"`
	CoursePhaseTypeName string      `json:"course_phase_type_name"`
}

func (q *Queries) GetCoursePhaseSequence(ctx context.Context, courseID uuid.UUID) ([]GetCoursePhaseSequenceRow, error) {
	rows, err := q.db.Query(ctx, getCoursePhaseSequence, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCoursePhaseSequenceRow
	for rows.Next() {
		var i GetCoursePhaseSequenceRow
		if err := rows.Scan(
			&i.ID,
			&i.CourseID,
			&i.Name,
			&i.IsInitialPhase,
			&i.CoursePhaseTypeID,
			&i.SequenceOrder,
			&i.CoursePhaseTypeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotOrderedCoursePhases = `-- name: GetNotOrderedCoursePhases :many
WITH RECURSIVE phase_sequence AS (
    -- Select the initial phase
    SELECT cp.id
    FROM course_phase cp
    WHERE cp.course_id = $1 AND cp.is_initial_phase = true

    UNION ALL

    -- Select all subsequent phases that are reachable from the initial phase
    SELECT cp.id
    FROM course_phase cp
    INNER JOIN course_phase_graph g ON g.to_course_phase_id = cp.id
    INNER JOIN phase_sequence ps ON g.from_course_phase_id = ps.id
)
SELECT cp.id, cp.course_id, cp.name, cp.restricted_data, cp.is_initial_phase, cp.course_phase_type_id, cp.student_readable_data, cpt.name AS course_phase_type_name
FROM course_phase cp
INNER JOIN course_phase_type cpt ON cp.course_phase_type_id = cpt.id
WHERE cp.course_id = $1
  AND cp.is_initial_phase = false
  AND cp.id NOT IN (SELECT id FROM phase_sequence)
`

type GetNotOrderedCoursePhasesRow struct {
	ID                  uuid.UUID   `json:"id"`
	CourseID            uuid.UUID   `json:"course_id"`
	Name                pgtype.Text `json:"name"`
	RestrictedData      []byte      `json:"restricted_data"`
	IsInitialPhase      bool        `json:"is_initial_phase"`
	CoursePhaseTypeID   uuid.UUID   `json:"course_phase_type_id"`
	StudentReadableData []byte      `json:"student_readable_data"`
	CoursePhaseTypeName string      `json:"course_phase_type_name"`
}

func (q *Queries) GetNotOrderedCoursePhases(ctx context.Context, courseID uuid.UUID) ([]GetNotOrderedCoursePhasesRow, error) {
	rows, err := q.db.Query(ctx, getNotOrderedCoursePhases, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNotOrderedCoursePhasesRow
	for rows.Next() {
		var i GetNotOrderedCoursePhasesRow
		if err := rows.Scan(
			&i.ID,
			&i.CourseID,
			&i.Name,
			&i.RestrictedData,
			&i.IsInitialPhase,
			&i.CoursePhaseTypeID,
			&i.StudentReadableData,
			&i.CoursePhaseTypeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInitialCoursePhase = `-- name: UpdateInitialCoursePhase :exec
UPDATE course_phase
SET is_initial_phase = CASE 
    WHEN id = $2 THEN true
    ELSE false
END
WHERE course_id = $1
`

type UpdateInitialCoursePhaseParams struct {
	CourseID uuid.UUID `json:"course_id"`
	ID       uuid.UUID `json:"id"`
}

func (q *Queries) UpdateInitialCoursePhase(ctx context.Context, arg UpdateInitialCoursePhaseParams) error {
	_, err := q.db.Exec(ctx, updateInitialCoursePhase, arg.CourseID, arg.ID)
	return err
}
