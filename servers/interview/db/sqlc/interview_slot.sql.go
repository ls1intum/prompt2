// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: interview_slot.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countAssignmentsBySlot = `-- name: CountAssignmentsBySlot :one
SELECT COUNT(*) FROM interview_assignment
WHERE interview_slot_id = $1
`

func (q *Queries) CountAssignmentsBySlot(ctx context.Context, interviewSlotID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countAssignmentsBySlot, interviewSlotID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createInterviewAssignment = `-- name: CreateInterviewAssignment :one
INSERT INTO interview_assignment (
    interview_slot_id,
    course_participation_id
) VALUES (
    $1, $2
) RETURNING id, interview_slot_id, course_participation_id, assigned_at
`

type CreateInterviewAssignmentParams struct {
	InterviewSlotID       uuid.UUID `json:"interview_slot_id"`
	CourseParticipationID uuid.UUID `json:"course_participation_id"`
}

func (q *Queries) CreateInterviewAssignment(ctx context.Context, arg CreateInterviewAssignmentParams) (InterviewAssignment, error) {
	row := q.db.QueryRow(ctx, createInterviewAssignment, arg.InterviewSlotID, arg.CourseParticipationID)
	var i InterviewAssignment
	err := row.Scan(
		&i.ID,
		&i.InterviewSlotID,
		&i.CourseParticipationID,
		&i.AssignedAt,
	)
	return i, err
}

const createInterviewSlot = `-- name: CreateInterviewSlot :one
INSERT INTO interview_slot (
    course_phase_id,
    start_time,
    end_time,
    location,
    capacity
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, course_phase_id, start_time, end_time, location, capacity, created_at, updated_at
`

type CreateInterviewSlotParams struct {
	CoursePhaseID uuid.UUID          `json:"course_phase_id"`
	StartTime     pgtype.Timestamptz `json:"start_time"`
	EndTime       pgtype.Timestamptz `json:"end_time"`
	Location      pgtype.Text        `json:"location"`
	Capacity      int32              `json:"capacity"`
}

func (q *Queries) CreateInterviewSlot(ctx context.Context, arg CreateInterviewSlotParams) (InterviewSlot, error) {
	row := q.db.QueryRow(ctx, createInterviewSlot,
		arg.CoursePhaseID,
		arg.StartTime,
		arg.EndTime,
		arg.Location,
		arg.Capacity,
	)
	var i InterviewSlot
	err := row.Scan(
		&i.ID,
		&i.CoursePhaseID,
		&i.StartTime,
		&i.EndTime,
		&i.Location,
		&i.Capacity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteInterviewAssignment = `-- name: DeleteInterviewAssignment :exec
DELETE FROM interview_assignment
WHERE id = $1
`

func (q *Queries) DeleteInterviewAssignment(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteInterviewAssignment, id)
	return err
}

const deleteInterviewAssignmentByParticipation = `-- name: DeleteInterviewAssignmentByParticipation :exec
DELETE FROM interview_assignment
WHERE course_participation_id = $1
`

func (q *Queries) DeleteInterviewAssignmentByParticipation(ctx context.Context, courseParticipationID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteInterviewAssignmentByParticipation, courseParticipationID)
	return err
}

const deleteInterviewSlot = `-- name: DeleteInterviewSlot :exec
DELETE FROM interview_slot
WHERE id = $1
`

func (q *Queries) DeleteInterviewSlot(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteInterviewSlot, id)
	return err
}

const getInterviewAssignment = `-- name: GetInterviewAssignment :one
SELECT id, interview_slot_id, course_participation_id, assigned_at FROM interview_assignment
WHERE id = $1
`

func (q *Queries) GetInterviewAssignment(ctx context.Context, id uuid.UUID) (InterviewAssignment, error) {
	row := q.db.QueryRow(ctx, getInterviewAssignment, id)
	var i InterviewAssignment
	err := row.Scan(
		&i.ID,
		&i.InterviewSlotID,
		&i.CourseParticipationID,
		&i.AssignedAt,
	)
	return i, err
}

const getInterviewAssignmentByParticipation = `-- name: GetInterviewAssignmentByParticipation :one
SELECT ia.id, ia.interview_slot_id, ia.course_participation_id, ia.assigned_at FROM interview_assignment ia
JOIN interview_slot s ON ia.interview_slot_id = s.id
WHERE ia.course_participation_id = $1 AND s.course_phase_id = $2
`

type GetInterviewAssignmentByParticipationParams struct {
	CourseParticipationID uuid.UUID `json:"course_participation_id"`
	CoursePhaseID         uuid.UUID `json:"course_phase_id"`
}

func (q *Queries) GetInterviewAssignmentByParticipation(ctx context.Context, arg GetInterviewAssignmentByParticipationParams) (InterviewAssignment, error) {
	row := q.db.QueryRow(ctx, getInterviewAssignmentByParticipation, arg.CourseParticipationID, arg.CoursePhaseID)
	var i InterviewAssignment
	err := row.Scan(
		&i.ID,
		&i.InterviewSlotID,
		&i.CourseParticipationID,
		&i.AssignedAt,
	)
	return i, err
}

const getInterviewAssignmentsBySlot = `-- name: GetInterviewAssignmentsBySlot :many
SELECT id, interview_slot_id, course_participation_id, assigned_at FROM interview_assignment
WHERE interview_slot_id = $1
`

func (q *Queries) GetInterviewAssignmentsBySlot(ctx context.Context, interviewSlotID uuid.UUID) ([]InterviewAssignment, error) {
	rows, err := q.db.Query(ctx, getInterviewAssignmentsBySlot, interviewSlotID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InterviewAssignment
	for rows.Next() {
		var i InterviewAssignment
		if err := rows.Scan(
			&i.ID,
			&i.InterviewSlotID,
			&i.CourseParticipationID,
			&i.AssignedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInterviewSlot = `-- name: GetInterviewSlot :one
SELECT id, course_phase_id, start_time, end_time, location, capacity, created_at, updated_at FROM interview_slot
WHERE id = $1
`

func (q *Queries) GetInterviewSlot(ctx context.Context, id uuid.UUID) (InterviewSlot, error) {
	row := q.db.QueryRow(ctx, getInterviewSlot, id)
	var i InterviewSlot
	err := row.Scan(
		&i.ID,
		&i.CoursePhaseID,
		&i.StartTime,
		&i.EndTime,
		&i.Location,
		&i.Capacity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInterviewSlotWithAssignments = `-- name: GetInterviewSlotWithAssignments :many
SELECT 
    s.id as slot_id,
    s.course_phase_id,
    s.start_time,
    s.end_time,
    s.location,
    s.capacity,
    s.created_at,
    s.updated_at,
    a.id as assignment_id,
    a.course_participation_id,
    a.assigned_at
FROM interview_slot s
LEFT JOIN interview_assignment a ON s.id = a.interview_slot_id
WHERE s.course_phase_id = $1
ORDER BY s.start_time ASC
`

type GetInterviewSlotWithAssignmentsRow struct {
	SlotID                uuid.UUID          `json:"slot_id"`
	CoursePhaseID         uuid.UUID          `json:"course_phase_id"`
	StartTime             pgtype.Timestamptz `json:"start_time"`
	EndTime               pgtype.Timestamptz `json:"end_time"`
	Location              pgtype.Text        `json:"location"`
	Capacity              int32              `json:"capacity"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	AssignmentID          pgtype.UUID        `json:"assignment_id"`
	CourseParticipationID pgtype.UUID        `json:"course_participation_id"`
	AssignedAt            pgtype.Timestamptz `json:"assigned_at"`
}

func (q *Queries) GetInterviewSlotWithAssignments(ctx context.Context, coursePhaseID uuid.UUID) ([]GetInterviewSlotWithAssignmentsRow, error) {
	rows, err := q.db.Query(ctx, getInterviewSlotWithAssignments, coursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInterviewSlotWithAssignmentsRow
	for rows.Next() {
		var i GetInterviewSlotWithAssignmentsRow
		if err := rows.Scan(
			&i.SlotID,
			&i.CoursePhaseID,
			&i.StartTime,
			&i.EndTime,
			&i.Location,
			&i.Capacity,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AssignmentID,
			&i.CourseParticipationID,
			&i.AssignedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInterviewSlotsByCoursePhase = `-- name: GetInterviewSlotsByCoursePhase :many
SELECT id, course_phase_id, start_time, end_time, location, capacity, created_at, updated_at FROM interview_slot
WHERE course_phase_id = $1
ORDER BY start_time ASC
`

func (q *Queries) GetInterviewSlotsByCoursePhase(ctx context.Context, coursePhaseID uuid.UUID) ([]InterviewSlot, error) {
	rows, err := q.db.Query(ctx, getInterviewSlotsByCoursePhase, coursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InterviewSlot
	for rows.Next() {
		var i InterviewSlot
		if err := rows.Scan(
			&i.ID,
			&i.CoursePhaseID,
			&i.StartTime,
			&i.EndTime,
			&i.Location,
			&i.Capacity,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInterviewSlot = `-- name: UpdateInterviewSlot :one
UPDATE interview_slot
SET start_time = $2,
    end_time = $3,
    location = $4,
    capacity = $5,
    updated_at = now()
WHERE id = $1
RETURNING id, course_phase_id, start_time, end_time, location, capacity, created_at, updated_at
`

type UpdateInterviewSlotParams struct {
	ID        uuid.UUID          `json:"id"`
	StartTime pgtype.Timestamptz `json:"start_time"`
	EndTime   pgtype.Timestamptz `json:"end_time"`
	Location  pgtype.Text        `json:"location"`
	Capacity  int32              `json:"capacity"`
}

func (q *Queries) UpdateInterviewSlot(ctx context.Context, arg UpdateInterviewSlotParams) (InterviewSlot, error) {
	row := q.db.QueryRow(ctx, updateInterviewSlot,
		arg.ID,
		arg.StartTime,
		arg.EndTime,
		arg.Location,
		arg.Capacity,
	)
	var i InterviewSlot
	err := row.Scan(
		&i.ID,
		&i.CoursePhaseID,
		&i.StartTime,
		&i.EndTime,
		&i.Location,
		&i.Capacity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
