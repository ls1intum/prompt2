package competencies

import (
	"context"
	"errors"
	"fmt"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jackc/pgx/v5/pgxpool"
	promptSDK "github.com/ls1intum/prompt-sdk"
	"github.com/ls1intum/prompt2/servers/assessment/competencies/competencyDTO"
	db "github.com/ls1intum/prompt2/servers/assessment/db/sqlc"
	"github.com/ls1intum/prompt2/servers/assessment/schemaModification"
	log "github.com/sirupsen/logrus"
)

type CompetencyService struct {
	queries db.Queries
	conn    *pgxpool.Pool
}

var CompetencyServiceSingleton *CompetencyService

func CreateCompetency(ctx context.Context, coursePhaseID uuid.UUID, req competencyDTO.CreateCompetencyRequest) error {
	category, err := CompetencyServiceSingleton.queries.GetCategory(ctx, req.CategoryID)
	if err != nil {
		log.Error("could not get category: ", err)
		return errors.New("could not get category")
	}

	result, err := schemaModification.GetOrCopySchemaForWrite(
		ctx,
		CompetencyServiceSingleton.queries,
		category.AssessmentSchemaID,
		req.CategoryID, // Pass category ID to get it mapped if schema is copied
		coursePhaseID,
	)
	if err != nil {
		return err
	}

	tx, err := CompetencyServiceSingleton.conn.Begin(ctx)
	if err != nil {
		return err
	}
	defer promptSDK.DeferDBRollback(tx, ctx)
	qtx := CompetencyServiceSingleton.queries.WithTx(tx)

	err = qtx.CreateCompetency(ctx, db.CreateCompetencyParams{
		ID:                  uuid.New(),
		CategoryID:          result.TargetEntityID,
		Name:                req.Name,
		ShortName:           pgtype.Text{String: req.ShortName, Valid: true},
		Description:         pgtype.Text{String: req.Description, Valid: true},
		DescriptionVeryBad:  req.DescriptionVeryBad,
		DescriptionBad:      req.DescriptionBad,
		DescriptionOk:       req.DescriptionOk,
		DescriptionGood:     req.DescriptionGood,
		DescriptionVeryGood: req.DescriptionVeryGood,
		Weight:              req.Weight,
	})
	if err != nil {
		log.Error("could not create competency: ", err)
		return errors.New("could not create competency")
	}

	if err := tx.Commit(ctx); err != nil {
		log.Error("could not commit competency creation: ", err)
		return fmt.Errorf("failed to commit transaction: %w", err)
	}

	return nil
}

func GetCompetency(ctx context.Context, id uuid.UUID) (db.Competency, error) {
	competency, err := CompetencyServiceSingleton.queries.GetCompetency(ctx, id)
	if err != nil {
		log.Error("could not get competency: ", err)
		return db.Competency{}, errors.New("could not get competency")
	}
	return competency, nil
}

func ListCompetencies(ctx context.Context) ([]db.Competency, error) {
	competencies, err := CompetencyServiceSingleton.queries.ListCompetencies(ctx)
	if err != nil {
		log.Error("could not list competencies: ", err)
		return nil, errors.New("could not list competencies")
	}
	return competencies, nil
}

func ListCompetenciesByCategory(ctx context.Context, categoryID uuid.UUID) ([]db.Competency, error) {
	competencies, err := CompetencyServiceSingleton.queries.ListCompetenciesByCategory(ctx, categoryID)
	if err != nil {
		log.Error("could not list competencies by category: ", err)
		return nil, errors.New("could not list competencies by category")
	}
	return competencies, nil
}

func UpdateCompetency(ctx context.Context, id uuid.UUID, coursePhaseID uuid.UUID, req competencyDTO.UpdateCompetencyRequest) error {
	currentSchemaID, err := CompetencyServiceSingleton.queries.GetAssessmentSchemaIDByCompetency(ctx, id)
	if err != nil {
		log.WithError(err).Error("Failed to get assessment schema ID for competency")
		return errors.New("failed to get assessment schema ID for competency")
	}

	result, err := schemaModification.GetOrCopySchemaForWrite(
		ctx,
		CompetencyServiceSingleton.queries,
		currentSchemaID,
		id,
		coursePhaseID,
	)
	if err != nil {
		return err
	}

	err = CompetencyServiceSingleton.queries.UpdateCompetency(ctx, db.UpdateCompetencyParams{
		ID:                  result.TargetEntityID,
		CategoryID:          req.CategoryID,
		Name:                req.Name,
		ShortName:           pgtype.Text{String: req.ShortName, Valid: true},
		Description:         pgtype.Text{String: req.Description, Valid: true},
		DescriptionVeryBad:  req.DescriptionVeryBad,
		DescriptionBad:      req.DescriptionBad,
		DescriptionOk:       req.DescriptionOk,
		DescriptionGood:     req.DescriptionGood,
		DescriptionVeryGood: req.DescriptionVeryGood,
		Weight:              req.Weight,
	})
	if err != nil {
		log.Error("could not update competency: ", err)
		return errors.New("could not update competency")
	}

	return nil
}

func DeleteCompetency(ctx context.Context, id uuid.UUID, coursePhaseID uuid.UUID) error {
	currentSchemaID, err := CompetencyServiceSingleton.queries.GetAssessmentSchemaIDByCompetency(ctx, id)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil
		}
		log.WithError(err).Error("Failed to get assessment schema ID for competency")
		return errors.New("failed to get assessment schema ID for competency")
	}

	result, err := schemaModification.GetOrCopySchemaForWrite(
		ctx,
		CompetencyServiceSingleton.queries,
		currentSchemaID,
		id,
		coursePhaseID,
	)
	if err != nil {
		return err
	}

	err = CompetencyServiceSingleton.queries.DeleteCompetency(ctx, result.TargetEntityID)
	if err != nil {
		log.Error("could not delete competency: ", err)
		return errors.New("could not delete competency")
	}

	return nil
}
