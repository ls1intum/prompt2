// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: evaluation.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const countRemainingEvaluationsForStudent = `-- name: CountRemainingEvaluationsForStudent :one
WITH is_self_evaluation AS (SELECT $1::uuid = $2::uuid AS is_self),
     total_competencies AS (SELECT COUNT(*) AS total
                            FROM competency c
                                     INNER JOIN category cat ON c.category_id = cat.id
                                     INNER JOIN course_phase_config cpc ON
                                CASE
                                    WHEN (SELECT is_self FROM is_self_evaluation) THEN
                                        cat.assessment_template_id = cpc.self_evaluation_template
                                    ELSE
                                        cat.assessment_template_id = cpc.peer_evaluation_template
                                    END
                            WHERE cpc.course_phase_id = $3),
     evaluated_competencies AS (SELECT COUNT(*) AS evaluated
                                FROM evaluation e
                                         INNER JOIN competency c ON e.competency_id = c.id
                                         INNER JOIN category cat ON c.category_id = cat.id
                                         INNER JOIN course_phase_config cpc ON
                                    CASE
                                        WHEN (SELECT is_self FROM is_self_evaluation) THEN
                                            cat.assessment_template_id = cpc.self_evaluation_template
                                        ELSE
                                            cat.assessment_template_id = cpc.peer_evaluation_template
                                        END
                                WHERE e.course_participation_id = $1
                                  AND e.course_phase_id = $3
                                  AND e.author_course_participation_id = $2
                                  AND cpc.course_phase_id = $3)
SELECT (SELECT total FROM total_competencies) - (SELECT evaluated FROM evaluated_competencies) AS remaining_evaluations
`

type CountRemainingEvaluationsForStudentParams struct {
	Column1       uuid.UUID `json:"column_1"`
	Column2       uuid.UUID `json:"column_2"`
	CoursePhaseID uuid.UUID `json:"course_phase_id"`
}

func (q *Queries) CountRemainingEvaluationsForStudent(ctx context.Context, arg CountRemainingEvaluationsForStudentParams) (int32, error) {
	row := q.db.QueryRow(ctx, countRemainingEvaluationsForStudent, arg.Column1, arg.Column2, arg.CoursePhaseID)
	var remaining_evaluations int32
	err := row.Scan(&remaining_evaluations)
	return remaining_evaluations, err
}

const countRemainingEvaluationsForStudentByType = `-- name: CountRemainingEvaluationsForStudentByType :one
WITH total_competencies AS (SELECT COUNT(*) AS total
                            FROM competency c
                                     INNER JOIN category cat ON c.category_id = cat.id
                                     INNER JOIN course_phase_config cpc ON
                                CASE
                                    WHEN $4::evaluation_type = 'self' THEN
                                        cat.assessment_template_id = cpc.self_evaluation_template
                                    WHEN $4::evaluation_type = 'peer' THEN
                                        cat.assessment_template_id = cpc.peer_evaluation_template
                                    ELSE
                                        cat.assessment_template_id = cpc.assessment_template_id
                                    END
                            WHERE cpc.course_phase_id = $3),
     evaluated_competencies AS (SELECT COUNT(*) AS evaluated
                                FROM evaluation e
                                         INNER JOIN competency c ON e.competency_id = c.id
                                         INNER JOIN category cat ON c.category_id = cat.id
                                         INNER JOIN course_phase_config cpc ON
                                    CASE
                                        WHEN $4::evaluation_type = 'self' THEN
                                            cat.assessment_template_id = cpc.self_evaluation_template
                                        WHEN $4::evaluation_type = 'peer' THEN
                                            cat.assessment_template_id = cpc.peer_evaluation_template
                                        ELSE
                                            cat.assessment_template_id = cpc.assessment_template_id
                                        END
                                WHERE e.course_participation_id = $1
                                  AND e.course_phase_id = $3
                                  AND e.author_course_participation_id = $2
                                  AND e.type = $4::evaluation_type
                                  AND cpc.course_phase_id = $3)
SELECT (SELECT total FROM total_competencies) - (SELECT evaluated FROM evaluated_competencies) AS remaining_evaluations
`

type CountRemainingEvaluationsForStudentByTypeParams struct {
	CourseParticipationID       uuid.UUID   `json:"course_participation_id"`
	AuthorCourseParticipationID uuid.UUID   `json:"author_course_participation_id"`
	CoursePhaseID               uuid.UUID   `json:"course_phase_id"`
	Column4                     interface{} `json:"column_4"`
}

func (q *Queries) CountRemainingEvaluationsForStudentByType(ctx context.Context, arg CountRemainingEvaluationsForStudentByTypeParams) (int32, error) {
	row := q.db.QueryRow(ctx, countRemainingEvaluationsForStudentByType,
		arg.CourseParticipationID,
		arg.AuthorCourseParticipationID,
		arg.CoursePhaseID,
		arg.Column4,
	)
	var remaining_evaluations int32
	err := row.Scan(&remaining_evaluations)
	return remaining_evaluations, err
}

const createOrUpdateEvaluation = `-- name: CreateOrUpdateEvaluation :exec
INSERT INTO evaluation (course_participation_id,
                        course_phase_id,
                        competency_id,
                        score_level,
                        author_course_participation_id,
                        type)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (course_participation_id, course_phase_id, competency_id, author_course_participation_id)
    DO UPDATE SET score_level  = EXCLUDED.score_level,
                  type         = EXCLUDED.type,
                  evaluated_at = CURRENT_TIMESTAMP
`

type CreateOrUpdateEvaluationParams struct {
	CourseParticipationID       uuid.UUID      `json:"course_participation_id"`
	CoursePhaseID               uuid.UUID      `json:"course_phase_id"`
	CompetencyID                uuid.UUID      `json:"competency_id"`
	ScoreLevel                  ScoreLevel     `json:"score_level"`
	AuthorCourseParticipationID uuid.UUID      `json:"author_course_participation_id"`
	Type                        AssessmentType `json:"type"`
}

func (q *Queries) CreateOrUpdateEvaluation(ctx context.Context, arg CreateOrUpdateEvaluationParams) error {
	_, err := q.db.Exec(ctx, createOrUpdateEvaluation,
		arg.CourseParticipationID,
		arg.CoursePhaseID,
		arg.CompetencyID,
		arg.ScoreLevel,
		arg.AuthorCourseParticipationID,
		arg.Type,
	)
	return err
}

const deleteEvaluation = `-- name: DeleteEvaluation :exec
DELETE
FROM evaluation
WHERE id = $1
`

func (q *Queries) DeleteEvaluation(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteEvaluation, id)
	return err
}

const getEvaluationByID = `-- name: GetEvaluationByID :one
SELECT id, course_participation_id, course_phase_id, competency_id, score_level, author_course_participation_id, evaluated_at, type
FROM evaluation
WHERE id = $1
`

func (q *Queries) GetEvaluationByID(ctx context.Context, id uuid.UUID) (Evaluation, error) {
	row := q.db.QueryRow(ctx, getEvaluationByID, id)
	var i Evaluation
	err := row.Scan(
		&i.ID,
		&i.CourseParticipationID,
		&i.CoursePhaseID,
		&i.CompetencyID,
		&i.ScoreLevel,
		&i.AuthorCourseParticipationID,
		&i.EvaluatedAt,
		&i.Type,
	)
	return i, err
}

const getEvaluationsByPhase = `-- name: GetEvaluationsByPhase :many
SELECT id, course_participation_id, course_phase_id, competency_id, score_level, author_course_participation_id, evaluated_at, type
FROM evaluation
WHERE course_phase_id = $1
`

func (q *Queries) GetEvaluationsByPhase(ctx context.Context, coursePhaseID uuid.UUID) ([]Evaluation, error) {
	rows, err := q.db.Query(ctx, getEvaluationsByPhase, coursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Evaluation
	for rows.Next() {
		var i Evaluation
		if err := rows.Scan(
			&i.ID,
			&i.CourseParticipationID,
			&i.CoursePhaseID,
			&i.CompetencyID,
			&i.ScoreLevel,
			&i.AuthorCourseParticipationID,
			&i.EvaluatedAt,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEvaluationsForAuthorInPhase = `-- name: GetEvaluationsForAuthorInPhase :many
SELECT id, course_participation_id, course_phase_id, competency_id, score_level, author_course_participation_id, evaluated_at, type
FROM evaluation
WHERE author_course_participation_id = $1
  AND course_phase_id = $2
`

type GetEvaluationsForAuthorInPhaseParams struct {
	AuthorCourseParticipationID uuid.UUID `json:"author_course_participation_id"`
	CoursePhaseID               uuid.UUID `json:"course_phase_id"`
}

func (q *Queries) GetEvaluationsForAuthorInPhase(ctx context.Context, arg GetEvaluationsForAuthorInPhaseParams) ([]Evaluation, error) {
	rows, err := q.db.Query(ctx, getEvaluationsForAuthorInPhase, arg.AuthorCourseParticipationID, arg.CoursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Evaluation
	for rows.Next() {
		var i Evaluation
		if err := rows.Scan(
			&i.ID,
			&i.CourseParticipationID,
			&i.CoursePhaseID,
			&i.CompetencyID,
			&i.ScoreLevel,
			&i.AuthorCourseParticipationID,
			&i.EvaluatedAt,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPeerEvaluationsByPhase = `-- name: GetPeerEvaluationsByPhase :many
SELECT id, course_participation_id, course_phase_id, competency_id, score_level, author_course_participation_id, evaluated_at, type
FROM evaluation
WHERE course_phase_id = $1
  AND type = 'peer'
`

func (q *Queries) GetPeerEvaluationsByPhase(ctx context.Context, coursePhaseID uuid.UUID) ([]Evaluation, error) {
	rows, err := q.db.Query(ctx, getPeerEvaluationsByPhase, coursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Evaluation
	for rows.Next() {
		var i Evaluation
		if err := rows.Scan(
			&i.ID,
			&i.CourseParticipationID,
			&i.CoursePhaseID,
			&i.CompetencyID,
			&i.ScoreLevel,
			&i.AuthorCourseParticipationID,
			&i.EvaluatedAt,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPeerEvaluationsForParticipantInPhase = `-- name: GetPeerEvaluationsForParticipantInPhase :many
SELECT id, course_participation_id, course_phase_id, competency_id, score_level, author_course_participation_id, evaluated_at, type
FROM evaluation
WHERE course_participation_id = $1
  AND course_phase_id = $2
  AND type = 'peer'
`

type GetPeerEvaluationsForParticipantInPhaseParams struct {
	CourseParticipationID uuid.UUID `json:"course_participation_id"`
	CoursePhaseID         uuid.UUID `json:"course_phase_id"`
}

func (q *Queries) GetPeerEvaluationsForParticipantInPhase(ctx context.Context, arg GetPeerEvaluationsForParticipantInPhaseParams) ([]Evaluation, error) {
	rows, err := q.db.Query(ctx, getPeerEvaluationsForParticipantInPhase, arg.CourseParticipationID, arg.CoursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Evaluation
	for rows.Next() {
		var i Evaluation
		if err := rows.Scan(
			&i.ID,
			&i.CourseParticipationID,
			&i.CoursePhaseID,
			&i.CompetencyID,
			&i.ScoreLevel,
			&i.AuthorCourseParticipationID,
			&i.EvaluatedAt,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSelfEvaluationsByPhase = `-- name: GetSelfEvaluationsByPhase :many
SELECT id, course_participation_id, course_phase_id, competency_id, score_level, author_course_participation_id, evaluated_at, type
FROM evaluation
WHERE course_phase_id = $1
  AND type = 'self'
`

func (q *Queries) GetSelfEvaluationsByPhase(ctx context.Context, coursePhaseID uuid.UUID) ([]Evaluation, error) {
	rows, err := q.db.Query(ctx, getSelfEvaluationsByPhase, coursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Evaluation
	for rows.Next() {
		var i Evaluation
		if err := rows.Scan(
			&i.ID,
			&i.CourseParticipationID,
			&i.CoursePhaseID,
			&i.CompetencyID,
			&i.ScoreLevel,
			&i.AuthorCourseParticipationID,
			&i.EvaluatedAt,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSelfEvaluationsForParticipantInPhase = `-- name: GetSelfEvaluationsForParticipantInPhase :many
SELECT id, course_participation_id, course_phase_id, competency_id, score_level, author_course_participation_id, evaluated_at, type
FROM evaluation
WHERE course_participation_id = $1
  AND course_phase_id = $2
  AND type = 'self'
`

type GetSelfEvaluationsForParticipantInPhaseParams struct {
	CourseParticipationID uuid.UUID `json:"course_participation_id"`
	CoursePhaseID         uuid.UUID `json:"course_phase_id"`
}

func (q *Queries) GetSelfEvaluationsForParticipantInPhase(ctx context.Context, arg GetSelfEvaluationsForParticipantInPhaseParams) ([]Evaluation, error) {
	rows, err := q.db.Query(ctx, getSelfEvaluationsForParticipantInPhase, arg.CourseParticipationID, arg.CoursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Evaluation
	for rows.Next() {
		var i Evaluation
		if err := rows.Scan(
			&i.ID,
			&i.CourseParticipationID,
			&i.CoursePhaseID,
			&i.CompetencyID,
			&i.ScoreLevel,
			&i.AuthorCourseParticipationID,
			&i.EvaluatedAt,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTutorEvaluationsByPhase = `-- name: GetTutorEvaluationsByPhase :many
SELECT id, course_participation_id, course_phase_id, competency_id, score_level, author_course_participation_id, evaluated_at, type
FROM evaluation
WHERE course_phase_id = $1
  AND type = 'tutor'
`

func (q *Queries) GetTutorEvaluationsByPhase(ctx context.Context, coursePhaseID uuid.UUID) ([]Evaluation, error) {
	rows, err := q.db.Query(ctx, getTutorEvaluationsByPhase, coursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Evaluation
	for rows.Next() {
		var i Evaluation
		if err := rows.Scan(
			&i.ID,
			&i.CourseParticipationID,
			&i.CoursePhaseID,
			&i.CompetencyID,
			&i.ScoreLevel,
			&i.AuthorCourseParticipationID,
			&i.EvaluatedAt,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
