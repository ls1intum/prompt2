// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: evaluation.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const createOrUpdateEvaluation = `-- name: CreateOrUpdateEvaluation :exec
INSERT INTO evaluation (course_participation_id,
                        course_phase_id,
                        competency_id,
                        score_level,
                        author_course_participation_id)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (course_participation_id, course_phase_id, competency_id, author_course_participation_id)
    DO UPDATE SET score_level  = EXCLUDED.score_level,
                  evaluated_at = CURRENT_TIMESTAMP
`

type CreateOrUpdateEvaluationParams struct {
	CourseParticipationID       uuid.UUID  `json:"course_participation_id"`
	CoursePhaseID               uuid.UUID  `json:"course_phase_id"`
	CompetencyID                uuid.UUID  `json:"competency_id"`
	ScoreLevel                  ScoreLevel `json:"score_level"`
	AuthorCourseParticipationID uuid.UUID  `json:"author_course_participation_id"`
}

func (q *Queries) CreateOrUpdateEvaluation(ctx context.Context, arg CreateOrUpdateEvaluationParams) error {
	_, err := q.db.Exec(ctx, createOrUpdateEvaluation,
		arg.CourseParticipationID,
		arg.CoursePhaseID,
		arg.CompetencyID,
		arg.ScoreLevel,
		arg.AuthorCourseParticipationID,
	)
	return err
}

const deleteEvaluation = `-- name: DeleteEvaluation :exec
DELETE
FROM evaluation
WHERE id = $1
`

func (q *Queries) DeleteEvaluation(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteEvaluation, id)
	return err
}

const getEvaluationByID = `-- name: GetEvaluationByID :one
SELECT id, course_participation_id, course_phase_id, competency_id, score_level, author_course_participation_id, evaluated_at
FROM evaluation
WHERE id = $1
`

func (q *Queries) GetEvaluationByID(ctx context.Context, id uuid.UUID) (Evaluation, error) {
	row := q.db.QueryRow(ctx, getEvaluationByID, id)
	var i Evaluation
	err := row.Scan(
		&i.ID,
		&i.CourseParticipationID,
		&i.CoursePhaseID,
		&i.CompetencyID,
		&i.ScoreLevel,
		&i.AuthorCourseParticipationID,
		&i.EvaluatedAt,
	)
	return i, err
}

const getEvaluationsByPhase = `-- name: GetEvaluationsByPhase :many
SELECT id, course_participation_id, course_phase_id, competency_id, score_level, author_course_participation_id, evaluated_at
FROM evaluation
WHERE course_phase_id = $1
`

func (q *Queries) GetEvaluationsByPhase(ctx context.Context, coursePhaseID uuid.UUID) ([]Evaluation, error) {
	rows, err := q.db.Query(ctx, getEvaluationsByPhase, coursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Evaluation
	for rows.Next() {
		var i Evaluation
		if err := rows.Scan(
			&i.ID,
			&i.CourseParticipationID,
			&i.CoursePhaseID,
			&i.CompetencyID,
			&i.ScoreLevel,
			&i.AuthorCourseParticipationID,
			&i.EvaluatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEvaluationsForAuthorInPhase = `-- name: GetEvaluationsForAuthorInPhase :many
SELECT id, course_participation_id, course_phase_id, competency_id, score_level, author_course_participation_id, evaluated_at
FROM evaluation
WHERE author_course_participation_id = $1
  AND course_phase_id = $2
`

type GetEvaluationsForAuthorInPhaseParams struct {
	AuthorCourseParticipationID uuid.UUID `json:"author_course_participation_id"`
	CoursePhaseID               uuid.UUID `json:"course_phase_id"`
}

func (q *Queries) GetEvaluationsForAuthorInPhase(ctx context.Context, arg GetEvaluationsForAuthorInPhaseParams) ([]Evaluation, error) {
	rows, err := q.db.Query(ctx, getEvaluationsForAuthorInPhase, arg.AuthorCourseParticipationID, arg.CoursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Evaluation
	for rows.Next() {
		var i Evaluation
		if err := rows.Scan(
			&i.ID,
			&i.CourseParticipationID,
			&i.CoursePhaseID,
			&i.CompetencyID,
			&i.ScoreLevel,
			&i.AuthorCourseParticipationID,
			&i.EvaluatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPeerEvaluationsByPhase = `-- name: GetPeerEvaluationsByPhase :many
SELECT id, course_participation_id, course_phase_id, competency_id, score_level, author_course_participation_id, evaluated_at
FROM evaluation
WHERE course_phase_id = $1
  AND course_participation_id != author_course_participation_id
`

func (q *Queries) GetPeerEvaluationsByPhase(ctx context.Context, coursePhaseID uuid.UUID) ([]Evaluation, error) {
	rows, err := q.db.Query(ctx, getPeerEvaluationsByPhase, coursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Evaluation
	for rows.Next() {
		var i Evaluation
		if err := rows.Scan(
			&i.ID,
			&i.CourseParticipationID,
			&i.CoursePhaseID,
			&i.CompetencyID,
			&i.ScoreLevel,
			&i.AuthorCourseParticipationID,
			&i.EvaluatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPeerEvaluationsForParticipantInPhase = `-- name: GetPeerEvaluationsForParticipantInPhase :many
SELECT id, course_participation_id, course_phase_id, competency_id, score_level, author_course_participation_id, evaluated_at
FROM evaluation
WHERE course_participation_id = $1
  AND course_phase_id = $2
  AND course_participation_id != author_course_participation_id
`

type GetPeerEvaluationsForParticipantInPhaseParams struct {
	CourseParticipationID uuid.UUID `json:"course_participation_id"`
	CoursePhaseID         uuid.UUID `json:"course_phase_id"`
}

func (q *Queries) GetPeerEvaluationsForParticipantInPhase(ctx context.Context, arg GetPeerEvaluationsForParticipantInPhaseParams) ([]Evaluation, error) {
	rows, err := q.db.Query(ctx, getPeerEvaluationsForParticipantInPhase, arg.CourseParticipationID, arg.CoursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Evaluation
	for rows.Next() {
		var i Evaluation
		if err := rows.Scan(
			&i.ID,
			&i.CourseParticipationID,
			&i.CoursePhaseID,
			&i.CompetencyID,
			&i.ScoreLevel,
			&i.AuthorCourseParticipationID,
			&i.EvaluatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSelfEvaluationsByPhase = `-- name: GetSelfEvaluationsByPhase :many
SELECT id, course_participation_id, course_phase_id, competency_id, score_level, author_course_participation_id, evaluated_at
FROM evaluation
WHERE course_phase_id = $1
  AND course_participation_id = author_course_participation_id
`

func (q *Queries) GetSelfEvaluationsByPhase(ctx context.Context, coursePhaseID uuid.UUID) ([]Evaluation, error) {
	rows, err := q.db.Query(ctx, getSelfEvaluationsByPhase, coursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Evaluation
	for rows.Next() {
		var i Evaluation
		if err := rows.Scan(
			&i.ID,
			&i.CourseParticipationID,
			&i.CoursePhaseID,
			&i.CompetencyID,
			&i.ScoreLevel,
			&i.AuthorCourseParticipationID,
			&i.EvaluatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSelfEvaluationsForParticipantInPhase = `-- name: GetSelfEvaluationsForParticipantInPhase :many
SELECT id, course_participation_id, course_phase_id, competency_id, score_level, author_course_participation_id, evaluated_at
FROM evaluation
WHERE course_participation_id = $1
  AND course_phase_id = $2
  AND course_participation_id = author_course_participation_id
`

type GetSelfEvaluationsForParticipantInPhaseParams struct {
	CourseParticipationID uuid.UUID `json:"course_participation_id"`
	CoursePhaseID         uuid.UUID `json:"course_phase_id"`
}

func (q *Queries) GetSelfEvaluationsForParticipantInPhase(ctx context.Context, arg GetSelfEvaluationsForParticipantInPhaseParams) ([]Evaluation, error) {
	rows, err := q.db.Query(ctx, getSelfEvaluationsForParticipantInPhase, arg.CourseParticipationID, arg.CoursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Evaluation
	for rows.Next() {
		var i Evaluation
		if err := rows.Scan(
			&i.ID,
			&i.CourseParticipationID,
			&i.CoursePhaseID,
			&i.CompetencyID,
			&i.ScoreLevel,
			&i.AuthorCourseParticipationID,
			&i.EvaluatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
