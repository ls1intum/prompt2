// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: assessment_completion.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const checkAssessmentCompletionExists = `-- name: CheckAssessmentCompletionExists :one
SELECT EXISTS (SELECT 1
               FROM assessment_completion
               WHERE course_participation_id = $1
                 AND course_phase_id = $2)
`

type CheckAssessmentCompletionExistsParams struct {
	CourseParticipationID uuid.UUID `json:"course_participation_id"`
	CoursePhaseID         uuid.UUID `json:"course_phase_id"`
}

func (q *Queries) CheckAssessmentCompletionExists(ctx context.Context, arg CheckAssessmentCompletionExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkAssessmentCompletionExists, arg.CourseParticipationID, arg.CoursePhaseID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createOrUpdateAssessmentCompletion = `-- name: CreateOrUpdateAssessmentCompletion :exec
INSERT INTO assessment_completion (course_participation_id,
                                   course_phase_id,
                                   completed_at,
                                   author,
                                   comment,
                                   grade_suggestion,
                                   completed)
VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (course_participation_id, course_phase_id)
    DO UPDATE
    SET completed_at     = EXCLUDED.completed_at,
        author           = EXCLUDED.author,
        comment          = EXCLUDED.comment,
        grade_suggestion = EXCLUDED.grade_suggestion,
        completed        = EXCLUDED.completed
`

type CreateOrUpdateAssessmentCompletionParams struct {
	CourseParticipationID uuid.UUID          `json:"course_participation_id"`
	CoursePhaseID         uuid.UUID          `json:"course_phase_id"`
	CompletedAt           pgtype.Timestamptz `json:"completed_at"`
	Author                string             `json:"author"`
	Comment               string             `json:"comment"`
	GradeSuggestion       pgtype.Numeric     `json:"grade_suggestion"`
	Completed             bool               `json:"completed"`
}

func (q *Queries) CreateOrUpdateAssessmentCompletion(ctx context.Context, arg CreateOrUpdateAssessmentCompletionParams) error {
	_, err := q.db.Exec(ctx, createOrUpdateAssessmentCompletion,
		arg.CourseParticipationID,
		arg.CoursePhaseID,
		arg.CompletedAt,
		arg.Author,
		arg.Comment,
		arg.GradeSuggestion,
		arg.Completed,
	)
	return err
}

const deleteAssessmentCompletion = `-- name: DeleteAssessmentCompletion :exec
DELETE
FROM assessment_completion
WHERE course_participation_id = $1
  AND course_phase_id = $2
`

type DeleteAssessmentCompletionParams struct {
	CourseParticipationID uuid.UUID `json:"course_participation_id"`
	CoursePhaseID         uuid.UUID `json:"course_phase_id"`
}

func (q *Queries) DeleteAssessmentCompletion(ctx context.Context, arg DeleteAssessmentCompletionParams) error {
	_, err := q.db.Exec(ctx, deleteAssessmentCompletion, arg.CourseParticipationID, arg.CoursePhaseID)
	return err
}

const getAllGrades = `-- name: GetAllGrades :many
SELECT course_participation_id, grade_suggestion
FROM assessment_completion
WHERE course_phase_id = $1
  AND completed = true
`

type GetAllGradesRow struct {
	CourseParticipationID uuid.UUID      `json:"course_participation_id"`
	GradeSuggestion       pgtype.Numeric `json:"grade_suggestion"`
}

func (q *Queries) GetAllGrades(ctx context.Context, coursePhaseID uuid.UUID) ([]GetAllGradesRow, error) {
	rows, err := q.db.Query(ctx, getAllGrades, coursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllGradesRow
	for rows.Next() {
		var i GetAllGradesRow
		if err := rows.Scan(&i.CourseParticipationID, &i.GradeSuggestion); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssessmentCompletion = `-- name: GetAssessmentCompletion :one
SELECT course_participation_id, course_phase_id, completed_at, author, comment, grade_suggestion, completed
FROM assessment_completion
WHERE course_participation_id = $1
  AND course_phase_id = $2
`

type GetAssessmentCompletionParams struct {
	CourseParticipationID uuid.UUID `json:"course_participation_id"`
	CoursePhaseID         uuid.UUID `json:"course_phase_id"`
}

func (q *Queries) GetAssessmentCompletion(ctx context.Context, arg GetAssessmentCompletionParams) (AssessmentCompletion, error) {
	row := q.db.QueryRow(ctx, getAssessmentCompletion, arg.CourseParticipationID, arg.CoursePhaseID)
	var i AssessmentCompletion
	err := row.Scan(
		&i.CourseParticipationID,
		&i.CoursePhaseID,
		&i.CompletedAt,
		&i.Author,
		&i.Comment,
		&i.GradeSuggestion,
		&i.Completed,
	)
	return i, err
}

const getAssessmentCompletionsByCoursePhase = `-- name: GetAssessmentCompletionsByCoursePhase :many
SELECT course_participation_id, course_phase_id, completed_at, author, comment, grade_suggestion, completed
FROM assessment_completion
WHERE course_phase_id = $1
`

func (q *Queries) GetAssessmentCompletionsByCoursePhase(ctx context.Context, coursePhaseID uuid.UUID) ([]AssessmentCompletion, error) {
	rows, err := q.db.Query(ctx, getAssessmentCompletionsByCoursePhase, coursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AssessmentCompletion
	for rows.Next() {
		var i AssessmentCompletion
		if err := rows.Scan(
			&i.CourseParticipationID,
			&i.CoursePhaseID,
			&i.CompletedAt,
			&i.Author,
			&i.Comment,
			&i.GradeSuggestion,
			&i.Completed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudentGrade = `-- name: GetStudentGrade :one
SELECT grade_suggestion
FROM assessment_completion
WHERE course_participation_id = $1
  AND course_phase_id = $2
  AND completed = true
`

type GetStudentGradeParams struct {
	CourseParticipationID uuid.UUID `json:"course_participation_id"`
	CoursePhaseID         uuid.UUID `json:"course_phase_id"`
}

func (q *Queries) GetStudentGrade(ctx context.Context, arg GetStudentGradeParams) (pgtype.Numeric, error) {
	row := q.db.QueryRow(ctx, getStudentGrade, arg.CourseParticipationID, arg.CoursePhaseID)
	var grade_suggestion pgtype.Numeric
	err := row.Scan(&grade_suggestion)
	return grade_suggestion, err
}

const markAssessmentAsFinished = `-- name: MarkAssessmentAsFinished :exec
UPDATE assessment_completion
SET completed    = true,
    completed_at = $3,
    author       = $4
WHERE course_participation_id = $1
  AND course_phase_id = $2
`

type MarkAssessmentAsFinishedParams struct {
	CourseParticipationID uuid.UUID          `json:"course_participation_id"`
	CoursePhaseID         uuid.UUID          `json:"course_phase_id"`
	CompletedAt           pgtype.Timestamptz `json:"completed_at"`
	Author                string             `json:"author"`
}

func (q *Queries) MarkAssessmentAsFinished(ctx context.Context, arg MarkAssessmentAsFinishedParams) error {
	_, err := q.db.Exec(ctx, markAssessmentAsFinished,
		arg.CourseParticipationID,
		arg.CoursePhaseID,
		arg.CompletedAt,
		arg.Author,
	)
	return err
}

const unmarkAssessmentAsFinished = `-- name: UnmarkAssessmentAsFinished :exec
UPDATE assessment_completion
SET completed = false
WHERE course_participation_id = $1
  AND course_phase_id = $2
`

type UnmarkAssessmentAsFinishedParams struct {
	CourseParticipationID uuid.UUID `json:"course_participation_id"`
	CoursePhaseID         uuid.UUID `json:"course_phase_id"`
}

func (q *Queries) UnmarkAssessmentAsFinished(ctx context.Context, arg UnmarkAssessmentAsFinishedParams) error {
	_, err := q.db.Exec(ctx, unmarkAssessmentAsFinished, arg.CourseParticipationID, arg.CoursePhaseID)
	return err
}
