// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: assessment_completion.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const checkAssessmentCompletionExists = `-- name: CheckAssessmentCompletionExists :one
SELECT EXISTS (
    SELECT 1
    FROM assessment_completion
    WHERE course_participation_id = $1
      AND course_phase_id = $2
  )
`

type CheckAssessmentCompletionExistsParams struct {
	CourseParticipationID uuid.UUID `json:"course_participation_id"`
	CoursePhaseID         uuid.UUID `json:"course_phase_id"`
}

func (q *Queries) CheckAssessmentCompletionExists(ctx context.Context, arg CheckAssessmentCompletionExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkAssessmentCompletionExists, arg.CourseParticipationID, arg.CoursePhaseID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getAssessmentCompletion = `-- name: GetAssessmentCompletion :one
SELECT course_participation_id,
  course_phase_id,
  completed_at,
  author
FROM assessment_completion
WHERE course_participation_id = $1
  AND course_phase_id = $2
`

type GetAssessmentCompletionParams struct {
	CourseParticipationID uuid.UUID `json:"course_participation_id"`
	CoursePhaseID         uuid.UUID `json:"course_phase_id"`
}

func (q *Queries) GetAssessmentCompletion(ctx context.Context, arg GetAssessmentCompletionParams) (AssessmentCompletion, error) {
	row := q.db.QueryRow(ctx, getAssessmentCompletion, arg.CourseParticipationID, arg.CoursePhaseID)
	var i AssessmentCompletion
	err := row.Scan(
		&i.CourseParticipationID,
		&i.CoursePhaseID,
		&i.CompletedAt,
		&i.Author,
	)
	return i, err
}

const getAssessmentCompletionsByCoursePhase = `-- name: GetAssessmentCompletionsByCoursePhase :many
SELECT course_participation_id, course_phase_id, completed_at, author
FROM assessment_completion
WHERE course_phase_id = $1
`

func (q *Queries) GetAssessmentCompletionsByCoursePhase(ctx context.Context, coursePhaseID uuid.UUID) ([]AssessmentCompletion, error) {
	rows, err := q.db.Query(ctx, getAssessmentCompletionsByCoursePhase, coursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AssessmentCompletion
	for rows.Next() {
		var i AssessmentCompletion
		if err := rows.Scan(
			&i.CourseParticipationID,
			&i.CoursePhaseID,
			&i.CompletedAt,
			&i.Author,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markAssessmentAsFinished = `-- name: MarkAssessmentAsFinished :exec
INSERT INTO assessment_completion (
    course_participation_id,
    course_phase_id,
    completed_at,
    author
  )
VALUES ($1, $2, $3, $4)
`

type MarkAssessmentAsFinishedParams struct {
	CourseParticipationID uuid.UUID          `json:"course_participation_id"`
	CoursePhaseID         uuid.UUID          `json:"course_phase_id"`
	CompletedAt           pgtype.Timestamptz `json:"completed_at"`
	Author                string             `json:"author"`
}

func (q *Queries) MarkAssessmentAsFinished(ctx context.Context, arg MarkAssessmentAsFinishedParams) error {
	_, err := q.db.Exec(ctx, markAssessmentAsFinished,
		arg.CourseParticipationID,
		arg.CoursePhaseID,
		arg.CompletedAt,
		arg.Author,
	)
	return err
}

const unmarkAssessmentAsFinished = `-- name: UnmarkAssessmentAsFinished :exec
DELETE FROM assessment_completion
WHERE course_participation_id = $1
  AND course_phase_id = $2
`

type UnmarkAssessmentAsFinishedParams struct {
	CourseParticipationID uuid.UUID `json:"course_participation_id"`
	CoursePhaseID         uuid.UUID `json:"course_phase_id"`
}

func (q *Queries) UnmarkAssessmentAsFinished(ctx context.Context, arg UnmarkAssessmentAsFinishedParams) error {
	_, err := q.db.Exec(ctx, unmarkAssessmentAsFinished, arg.CourseParticipationID, arg.CoursePhaseID)
	return err
}
