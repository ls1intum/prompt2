// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: feedback_item.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const createFeedbackItem = `-- name: CreateFeedbackItem :exec
INSERT INTO feedback_items (id,
                            feedback_type,
                            feedback_text,
                            course_participation_id,
                            course_phase_id,
                            author_course_participation_id,
                            type)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type CreateFeedbackItemParams struct {
	ID                          uuid.UUID      `json:"id"`
	FeedbackType                FeedbackType   `json:"feedback_type"`
	FeedbackText                string         `json:"feedback_text"`
	CourseParticipationID       uuid.UUID      `json:"course_participation_id"`
	CoursePhaseID               uuid.UUID      `json:"course_phase_id"`
	AuthorCourseParticipationID uuid.UUID      `json:"author_course_participation_id"`
	Type                        AssessmentType `json:"type"`
}

func (q *Queries) CreateFeedbackItem(ctx context.Context, arg CreateFeedbackItemParams) error {
	_, err := q.db.Exec(ctx, createFeedbackItem,
		arg.ID,
		arg.FeedbackType,
		arg.FeedbackText,
		arg.CourseParticipationID,
		arg.CoursePhaseID,
		arg.AuthorCourseParticipationID,
		arg.Type,
	)
	return err
}

const deleteFeedbackItem = `-- name: DeleteFeedbackItem :exec
DELETE
FROM feedback_items
WHERE id = $1
`

func (q *Queries) DeleteFeedbackItem(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteFeedbackItem, id)
	return err
}

const getFeedbackItem = `-- name: GetFeedbackItem :one
SELECT id, feedback_type, feedback_text, course_participation_id, course_phase_id, author_course_participation_id, created_at, type
FROM feedback_items
WHERE id = $1
`

func (q *Queries) GetFeedbackItem(ctx context.Context, id uuid.UUID) (FeedbackItem, error) {
	row := q.db.QueryRow(ctx, getFeedbackItem, id)
	var i FeedbackItem
	err := row.Scan(
		&i.ID,
		&i.FeedbackType,
		&i.FeedbackText,
		&i.CourseParticipationID,
		&i.CoursePhaseID,
		&i.AuthorCourseParticipationID,
		&i.CreatedAt,
		&i.Type,
	)
	return i, err
}

const listFeedbackItemsByAuthorInPhase = `-- name: ListFeedbackItemsByAuthorInPhase :many
SELECT id, feedback_type, feedback_text, course_participation_id, course_phase_id, author_course_participation_id, created_at, type
FROM feedback_items
WHERE author_course_participation_id = $1
  AND course_phase_id = $2
ORDER BY created_at
`

type ListFeedbackItemsByAuthorInPhaseParams struct {
	AuthorCourseParticipationID uuid.UUID `json:"author_course_participation_id"`
	CoursePhaseID               uuid.UUID `json:"course_phase_id"`
}

func (q *Queries) ListFeedbackItemsByAuthorInPhase(ctx context.Context, arg ListFeedbackItemsByAuthorInPhaseParams) ([]FeedbackItem, error) {
	rows, err := q.db.Query(ctx, listFeedbackItemsByAuthorInPhase, arg.AuthorCourseParticipationID, arg.CoursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FeedbackItem
	for rows.Next() {
		var i FeedbackItem
		if err := rows.Scan(
			&i.ID,
			&i.FeedbackType,
			&i.FeedbackText,
			&i.CourseParticipationID,
			&i.CoursePhaseID,
			&i.AuthorCourseParticipationID,
			&i.CreatedAt,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeedbackItemsForCoursePhase = `-- name: ListFeedbackItemsForCoursePhase :many
SELECT id, feedback_type, feedback_text, course_participation_id, course_phase_id, author_course_participation_id, created_at, type
FROM feedback_items
WHERE course_phase_id = $1
ORDER BY created_at
`

func (q *Queries) ListFeedbackItemsForCoursePhase(ctx context.Context, coursePhaseID uuid.UUID) ([]FeedbackItem, error) {
	rows, err := q.db.Query(ctx, listFeedbackItemsForCoursePhase, coursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FeedbackItem
	for rows.Next() {
		var i FeedbackItem
		if err := rows.Scan(
			&i.ID,
			&i.FeedbackType,
			&i.FeedbackText,
			&i.CourseParticipationID,
			&i.CoursePhaseID,
			&i.AuthorCourseParticipationID,
			&i.CreatedAt,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeedbackItemsForParticipantInPhase = `-- name: ListFeedbackItemsForParticipantInPhase :many
SELECT id, feedback_type, feedback_text, course_participation_id, course_phase_id, author_course_participation_id, created_at, type
FROM feedback_items
WHERE course_participation_id = $1
  AND course_phase_id = $2
  AND type != 'tutor'
ORDER BY created_at
`

type ListFeedbackItemsForParticipantInPhaseParams struct {
	CourseParticipationID uuid.UUID `json:"course_participation_id"`
	CoursePhaseID         uuid.UUID `json:"course_phase_id"`
}

func (q *Queries) ListFeedbackItemsForParticipantInPhase(ctx context.Context, arg ListFeedbackItemsForParticipantInPhaseParams) ([]FeedbackItem, error) {
	rows, err := q.db.Query(ctx, listFeedbackItemsForParticipantInPhase, arg.CourseParticipationID, arg.CoursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FeedbackItem
	for rows.Next() {
		var i FeedbackItem
		if err := rows.Scan(
			&i.ID,
			&i.FeedbackType,
			&i.FeedbackText,
			&i.CourseParticipationID,
			&i.CoursePhaseID,
			&i.AuthorCourseParticipationID,
			&i.CreatedAt,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeedbackItemsForTutorInPhase = `-- name: ListFeedbackItemsForTutorInPhase :many
SELECT id, feedback_type, feedback_text, course_participation_id, course_phase_id, author_course_participation_id, created_at, type
FROM feedback_items
WHERE feedback_items.course_participation_id = $1
  AND course_phase_id = $2
  AND type = 'tutor'
ORDER BY created_at
`

type ListFeedbackItemsForTutorInPhaseParams struct {
	CourseParticipationID uuid.UUID `json:"course_participation_id"`
	CoursePhaseID         uuid.UUID `json:"course_phase_id"`
}

func (q *Queries) ListFeedbackItemsForTutorInPhase(ctx context.Context, arg ListFeedbackItemsForTutorInPhaseParams) ([]FeedbackItem, error) {
	rows, err := q.db.Query(ctx, listFeedbackItemsForTutorInPhase, arg.CourseParticipationID, arg.CoursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FeedbackItem
	for rows.Next() {
		var i FeedbackItem
		if err := rows.Scan(
			&i.ID,
			&i.FeedbackType,
			&i.FeedbackText,
			&i.CourseParticipationID,
			&i.CoursePhaseID,
			&i.AuthorCourseParticipationID,
			&i.CreatedAt,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFeedbackItem = `-- name: UpdateFeedbackItem :exec
UPDATE feedback_items
SET feedback_type                  = $2,
    feedback_text                  = $3,
    course_participation_id        = $4,
    course_phase_id                = $5,
    author_course_participation_id = $6,
    type                           = $7
WHERE id = $1
`

type UpdateFeedbackItemParams struct {
	ID                          uuid.UUID      `json:"id"`
	FeedbackType                FeedbackType   `json:"feedback_type"`
	FeedbackText                string         `json:"feedback_text"`
	CourseParticipationID       uuid.UUID      `json:"course_participation_id"`
	CoursePhaseID               uuid.UUID      `json:"course_phase_id"`
	AuthorCourseParticipationID uuid.UUID      `json:"author_course_participation_id"`
	Type                        AssessmentType `json:"type"`
}

func (q *Queries) UpdateFeedbackItem(ctx context.Context, arg UpdateFeedbackItemParams) error {
	_, err := q.db.Exec(ctx, updateFeedbackItem,
		arg.ID,
		arg.FeedbackType,
		arg.FeedbackText,
		arg.CourseParticipationID,
		arg.CoursePhaseID,
		arg.AuthorCourseParticipationID,
		arg.Type,
	)
	return err
}
