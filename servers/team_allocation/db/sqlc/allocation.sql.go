// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: allocation.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createOrUpdateAllocation = `-- name: CreateOrUpdateAllocation :exec
INSERT INTO allocations AS a (
  id,
  course_participation_id,
  team_id,
  course_phase_id,
  created_at,
  updated_at
) VALUES (
  $1,
  $2,
  $3,
  $4,
  CURRENT_TIMESTAMP,
  CURRENT_TIMESTAMP
)
ON CONFLICT ON CONSTRAINT allocations_participation_phase_uk
DO UPDATE
SET team_id = EXCLUDED.team_id,
    updated_at = CURRENT_TIMESTAMP
`

type CreateOrUpdateAllocationParams struct {
	ID                    uuid.UUID `json:"id"`
	CourseParticipationID uuid.UUID `json:"course_participation_id"`
	TeamID                uuid.UUID `json:"team_id"`
	CoursePhaseID         uuid.UUID `json:"course_phase_id"`
}

func (q *Queries) CreateOrUpdateAllocation(ctx context.Context, arg CreateOrUpdateAllocationParams) error {
	_, err := q.db.Exec(ctx, createOrUpdateAllocation,
		arg.ID,
		arg.CourseParticipationID,
		arg.TeamID,
		arg.CoursePhaseID,
	)
	return err
}

const deleteAllocationsByPhase = `-- name: DeleteAllocationsByPhase :exec
DELETE
FROM allocations a
    USING team t
WHERE a.team_id = t.id
  AND t.course_phase_id = $1
`

func (q *Queries) DeleteAllocationsByPhase(ctx context.Context, coursePhaseID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAllocationsByPhase, coursePhaseID)
	return err
}

const getAggregatedAllocationsByCoursePhase = `-- name: GetAggregatedAllocationsByCoursePhase :many
SELECT team_id,
       array_agg(course_participation_id ORDER BY course_participation_id)::uuid[] AS student_ids
FROM allocations
WHERE course_phase_id = $1
GROUP BY team_id
ORDER BY team_id
`

type GetAggregatedAllocationsByCoursePhaseRow struct {
	TeamID     uuid.UUID   `json:"team_id"`
	StudentIds []uuid.UUID `json:"student_ids"`
}

func (q *Queries) GetAggregatedAllocationsByCoursePhase(ctx context.Context, coursePhaseID uuid.UUID) ([]GetAggregatedAllocationsByCoursePhaseRow, error) {
	rows, err := q.db.Query(ctx, getAggregatedAllocationsByCoursePhase, coursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAggregatedAllocationsByCoursePhaseRow
	for rows.Next() {
		var i GetAggregatedAllocationsByCoursePhaseRow
		if err := rows.Scan(&i.TeamID, &i.StudentIds); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllocationForStudent = `-- name: GetAllocationForStudent :one
SELECT id,
       course_participation_id,
       student_first_name,
       student_last_name,
       team_id,
       course_phase_id,
       created_at,
       updated_at
FROM allocations
WHERE course_participation_id = $1
  AND course_phase_id = $2
`

type GetAllocationForStudentParams struct {
	CourseParticipationID uuid.UUID `json:"course_participation_id"`
	CoursePhaseID         uuid.UUID `json:"course_phase_id"`
}

type GetAllocationForStudentRow struct {
	ID                    uuid.UUID        `json:"id"`
	CourseParticipationID uuid.UUID        `json:"course_participation_id"`
	StudentFirstName      string           `json:"student_first_name"`
	StudentLastName       string           `json:"student_last_name"`
	TeamID                uuid.UUID        `json:"team_id"`
	CoursePhaseID         uuid.UUID        `json:"course_phase_id"`
	CreatedAt             pgtype.Timestamp `json:"created_at"`
	UpdatedAt             pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) GetAllocationForStudent(ctx context.Context, arg GetAllocationForStudentParams) (GetAllocationForStudentRow, error) {
	row := q.db.QueryRow(ctx, getAllocationForStudent, arg.CourseParticipationID, arg.CoursePhaseID)
	var i GetAllocationForStudentRow
	err := row.Scan(
		&i.ID,
		&i.CourseParticipationID,
		&i.StudentFirstName,
		&i.StudentLastName,
		&i.TeamID,
		&i.CoursePhaseID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllocationsByCoursePhase = `-- name: GetAllocationsByCoursePhase :many
SELECT a.id, a.course_participation_id, a.team_id, a.course_phase_id, a.created_at, a.updated_at, a.student_first_name, a.student_last_name
FROM allocations a
WHERE a.course_phase_id = $1
`

func (q *Queries) GetAllocationsByCoursePhase(ctx context.Context, coursePhaseID uuid.UUID) ([]Allocation, error) {
	rows, err := q.db.Query(ctx, getAllocationsByCoursePhase, coursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Allocation
	for rows.Next() {
		var i Allocation
		if err := rows.Scan(
			&i.ID,
			&i.CourseParticipationID,
			&i.TeamID,
			&i.CoursePhaseID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StudentFirstName,
			&i.StudentLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamWithStudentNamesByID = `-- name: GetTeamWithStudentNamesByID :one
SELECT
  t.id,
  t.name,
  COALESCE(
    jsonb_agg(
      jsonb_build_object(
        'courseParticipationID', a.course_participation_id,
        'studentFirstName',           a.student_first_name,
        'studentLastName',            a.student_last_name
      )
      ORDER BY a.student_first_name
    ) FILTER (WHERE a.id IS NOT NULL),
    '[]'::jsonb
  )::jsonb AS team_members
FROM
  team t
LEFT JOIN
  allocations a
  ON t.id = a.team_id
WHERE
  t.id = $1
GROUP BY
  t.id, t.name
`

type GetTeamWithStudentNamesByIDRow struct {
	ID          uuid.UUID `json:"id"`
	Name        string    `json:"name"`
	TeamMembers []byte    `json:"team_members"`
}

func (q *Queries) GetTeamWithStudentNamesByID(ctx context.Context, id uuid.UUID) (GetTeamWithStudentNamesByIDRow, error) {
	row := q.db.QueryRow(ctx, getTeamWithStudentNamesByID, id)
	var i GetTeamWithStudentNamesByIDRow
	err := row.Scan(&i.ID, &i.Name, &i.TeamMembers)
	return i, err
}

const getTeamWithStudentNamesByTeamID = `-- name: GetTeamWithStudentNamesByTeamID :one
SELECT
  t.id,
  t.name,
  COALESCE(
    jsonb_agg(
      jsonb_build_object(
        'courseParticipationID', a.course_participation_id,
        'studentFirstName',           a.student_first_name,
        'studentLastName',            a.student_last_name
      )
      ORDER BY a.student_first_name
    ) FILTER (WHERE a.id IS NOT NULL),
    '[]'::jsonb
  )::jsonb AS team_members
FROM
  team t
LEFT JOIN
  allocations a
  ON t.id = a.team_id
WHERE
  t.course_phase_id = $1
  AND t.id = $2
GROUP BY
  t.id, t.name
ORDER BY
  t.name
`

type GetTeamWithStudentNamesByTeamIDParams struct {
	CoursePhaseID uuid.UUID `json:"course_phase_id"`
	ID            uuid.UUID `json:"id"`
}

type GetTeamWithStudentNamesByTeamIDRow struct {
	ID          uuid.UUID `json:"id"`
	Name        string    `json:"name"`
	TeamMembers []byte    `json:"team_members"`
}

func (q *Queries) GetTeamWithStudentNamesByTeamID(ctx context.Context, arg GetTeamWithStudentNamesByTeamIDParams) (GetTeamWithStudentNamesByTeamIDRow, error) {
	row := q.db.QueryRow(ctx, getTeamWithStudentNamesByTeamID, arg.CoursePhaseID, arg.ID)
	var i GetTeamWithStudentNamesByTeamIDRow
	err := row.Scan(&i.ID, &i.Name, &i.TeamMembers)
	return i, err
}

const getTeamsWithStudentNames = `-- name: GetTeamsWithStudentNames :many
SELECT
  t.id,
  t.name,
  COALESCE(
    jsonb_agg(
      jsonb_build_object(
        'courseParticipationID', a.course_participation_id,
        'studentFirstName',           a.student_first_name,
        'studentLastName',            a.student_last_name
      )
      ORDER BY a.student_first_name
    ) FILTER (WHERE a.id IS NOT NULL),
    '[]'::jsonb
  )::jsonb AS team_members
FROM
  team t
LEFT JOIN
  allocations a
  ON t.id = a.team_id
WHERE
  t.course_phase_id = $1
GROUP BY
  t.id, t.name
ORDER BY
  t.name
`

type GetTeamsWithStudentNamesRow struct {
	ID          uuid.UUID `json:"id"`
	Name        string    `json:"name"`
	TeamMembers []byte    `json:"team_members"`
}

func (q *Queries) GetTeamsWithStudentNames(ctx context.Context, coursePhaseID uuid.UUID) ([]GetTeamsWithStudentNamesRow, error) {
	rows, err := q.db.Query(ctx, getTeamsWithStudentNames, coursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamsWithStudentNamesRow
	for rows.Next() {
		var i GetTeamsWithStudentNamesRow
		if err := rows.Scan(&i.ID, &i.Name, &i.TeamMembers); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStudentNameForAllocation = `-- name: UpdateStudentNameForAllocation :exec
UPDATE allocations
SET student_first_name = $1,
    student_last_name = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE course_participation_id = $3
  AND course_phase_id = $4
`

type UpdateStudentNameForAllocationParams struct {
	StudentFirstName      string    `json:"student_first_name"`
	StudentLastName       string    `json:"student_last_name"`
	CourseParticipationID uuid.UUID `json:"course_participation_id"`
	CoursePhaseID         uuid.UUID `json:"course_phase_id"`
}

func (q *Queries) UpdateStudentNameForAllocation(ctx context.Context, arg UpdateStudentNameForAllocationParams) error {
	_, err := q.db.Exec(ctx, updateStudentNameForAllocation,
		arg.StudentFirstName,
		arg.StudentLastName,
		arg.CourseParticipationID,
		arg.CoursePhaseID,
	)
	return err
}
