# Prompt 2.0 Clients

## Overview
This repository contains the client-side implementation of PROMPT 2.0, a modular and scalable management platform for project-based teaching. The architecture is designed to promote reusability, modularity, and consistency across all components.

---

## Structure

### `core`
The main application that provides the foundational framework for the system:
- **Core Functionality:** Includes login, routing, and the admin console.
- **Component Host:** Serves as the central frame for loading other remote components (course phases).
- **Routing and Integration:** Manages navigation and integrates dynamically loaded course phase modules.

### `shared_library`
A library of reusable code and assets shared across all components, structured as follows:
- **Usage**:
  - The library is loaded in the `webpack.config.ts` of every component
  - `@` is configured and an alias for the path of the shared library, to make imports easier and cleaner
    - i.e. `import { Button } from @/components/ui/button`
- **Structure:**
  - **`@/components`**: Contains reusable React components.
    - **`@/components/ui`**: Generated components using `shadcn/ui` for a consistent design system.
  - **`@/network`**: Shared utilities for network requests (e.g., API calls, data fetching).
  - **`@/interfaces`**: Defines shared TypeScript model interfaces used throughout the application.
  - TODO: add state management and context providers once it is implemented

### `template_component`
A boilerplate component structure for creating new course phase modules:
- **Structure:**
  - `src/interface`: Interfaces specific to the component.
  - `src/network`: Network request handlers specific to the component.
  - `src/hierarchy/SamplePage`:
    - `components`: Folder for all React components specific to this page.
    - `samplePage.tsx`: Main file for the sample page implementation.
  - `src/utilities`: (Careful - many utilities might be useful to move to the shared library)
    - `helpers`: Helper functions specific to the component.
    - `hooks`: Custom React hooks specific to the component.
    - ...

---

## Configuration

### Tailwind CSS and `shadcn/ui`
The application uses **Tailwind CSS** for styling and `shadcn/ui` for generating reusable UI components:
- Tailwind classes ensure a consistent and responsive design across the application.
- Customize and extend components generated by `shadcn/ui` to meet project-specific needs.
- **Adding new `shadcn/ui` component**
  1. Navigate to the **root** of the `shared_library` folder
        ```sh
        cd shared_library
        ```
  2. Add the `shadcn/ui` component you want to add 
        ```sh
        yarn dlx shadcn add <component-name>
        ```
- **Using a `shadcn/ui` component**
  
  `import { Button } from @/components/ui/button`
- **Configuring Tailwind and `shadcn/ui`**
  - Tailwind and `shadcn/ui` are centrally configured in the `shared_library`, with the following files
    - Global Tailwind config: `shared_library/tailwind.config.js` 
      - `<your_component>/tailwind.config.js` imports the global tailwind config as default - overwrite rules only if necessary
    - CSS Settings: `shared_library/src/index.js`
      - **must** be imported in every `<your_component>/index.js`
    - Shadcn/ui config: `shared_library/components.json` 


### Installing dependencies
All dependencies that are shared between the components should be installed in the root directory by 
```sh
    yarn add <component-name>
```
Only dependencies specific to your component shall be added in the subfolder. 


### Webpack Module Federation
The clients are built using **Webpack**, leveraging **module federation** to dynamically load course phase components:
- **Exporting `<your_component>`**
    All exporting configs are set in `<your_component>/webpack.config.ts`
    ```ts
    devServer: {
      port: 3001, // set this to a free port
    },
    ...
    plugins: [
        ...
        new container.ModuleFederationPlugin({
            name: 'template_component',
            filename: 'remoteEntry.js', // this MUST remain unchanged - file is auto-generated during runtim
            exposes: {
            './App': './src/App', // define what you want to export
            },
            shared: { ... },
        }),
    ]
    ...
    ````

- **Loading `<your_component>` in the `core`**
  1. Add `<your_component>` to the `core/webpack.config.ts`
    ```ts
        new container.ModuleFederationPlugin({
            name: 'core',
            remotes: {
                template_component: 'template_component@[templateComponent2Url]/remoteEntry.js',
                // add your component here
            },
    ````
  2. Add a new url name to `core/src/global.d.ts`
  3. Define the url in `core/src/index.js` (currently statically)
  4. Import your component (TODO: update once we have a sidebar/router)
    ```ts
        const TemplateComponent = React.lazy(() => import('template_component/App'))

        <React.Suspense fallback='Loading...'>
            <ErrorBoundary fallback={<div>TemplateComponent is unavailable.</div>}>
                <TemplateComponent />
            </ErrorBoundary>
        </React.Suspense>
    ```

### ESLint
**ESLint** is used for code linting to maintain consistent coding standards across all components:
- The main file is located in the root directory: `eslint.config.mjs`
- Each component has its own eslint file, which imports the root config and allows for changes if necessary
  - `<your_component>/eslint.config.mjs` 

---

## Creating a New Course Phase Module
1. Copy the `template_component` folder and rename it to your new module name.
2. Implement specific interfaces, network handlers, and utilities as required.
3. Follow the standardized structure to ensure compatibility with the core application.
4. Register the new module with the core application for dynamic loading as described above in `webpack`.

This structure ensures a streamlined development process and maintains consistency across all course phase modules.
