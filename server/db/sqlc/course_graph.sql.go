// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: course_graph.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createCourseGraphConnection = `-- name: CreateCourseGraphConnection :exec
INSERT INTO course_phase_graph (from_course_phase_id, to_course_phase_id)
VALUES ($1, $2)
`

type CreateCourseGraphConnectionParams struct {
	FromCoursePhaseID uuid.UUID `json:"from_course_phase_id"`
	ToCoursePhaseID   uuid.UUID `json:"to_course_phase_id"`
}

func (q *Queries) CreateCourseGraphConnection(ctx context.Context, arg CreateCourseGraphConnectionParams) error {
	_, err := q.db.Exec(ctx, createCourseGraphConnection, arg.FromCoursePhaseID, arg.ToCoursePhaseID)
	return err
}

const deleteCourseGraph = `-- name: DeleteCourseGraph :exec
DELETE FROM course_phase_graph
WHERE from_course_phase_id IN 
    (SELECT id FROM course_phase WHERE course_id = $1)
`

func (q *Queries) DeleteCourseGraph(ctx context.Context, courseID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCourseGraph, courseID)
	return err
}

const getCoursePhaseSequence = `-- name: GetCoursePhaseSequence :many
WITH RECURSIVE phase_sequence AS (
    SELECT cp.id, cp.course_id, cp.name, cp.meta_data, cp.is_initial_phase, cp.course_phase_type_id, 1 AS sequence_order
    FROM course_phase cp
    WHERE cp.course_id = $1 AND cp.is_initial_phase = true

    UNION ALL

    SELECT cp.id, cp.course_id, cp.name, cp.meta_data, cp.is_initial_phase, cp.course_phase_type_id, ps.sequence_order + 1 AS sequence_order
    FROM course_phase cp
    INNER JOIN course_phase_graph g ON g.to_course_phase_id = cp.id
    INNER JOIN phase_sequence ps ON g.from_course_phase_id = ps.id
)
SELECT id, course_id, name, meta_data, is_initial_phase, course_phase_type_id, sequence_order
FROM phase_sequence
ORDER BY sequence_order
`

type GetCoursePhaseSequenceRow struct {
	ID                uuid.UUID   `json:"id"`
	CourseID          uuid.UUID   `json:"course_id"`
	Name              pgtype.Text `json:"name"`
	MetaData          []byte      `json:"meta_data"`
	IsInitialPhase    bool        `json:"is_initial_phase"`
	CoursePhaseTypeID uuid.UUID   `json:"course_phase_type_id"`
	SequenceOrder     int32       `json:"sequence_order"`
}

func (q *Queries) GetCoursePhaseSequence(ctx context.Context, courseID uuid.UUID) ([]GetCoursePhaseSequenceRow, error) {
	rows, err := q.db.Query(ctx, getCoursePhaseSequence, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCoursePhaseSequenceRow
	for rows.Next() {
		var i GetCoursePhaseSequenceRow
		if err := rows.Scan(
			&i.ID,
			&i.CourseID,
			&i.Name,
			&i.MetaData,
			&i.IsInitialPhase,
			&i.CoursePhaseTypeID,
			&i.SequenceOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotOrderedCoursePhases = `-- name: GetNotOrderedCoursePhases :many
SELECT cp.id, cp.course_id, cp.name, cp.meta_data, cp.is_initial_phase, cp.course_phase_type_id
FROM course_phase cp
WHERE cp.course_id = $1
  AND cp.is_initial_phase = FALSE
  AND NOT EXISTS (
      SELECT from_course_phase_id, to_course_phase_id
      FROM course_phase_graph g
      WHERE g.from_course_phase_id = cp.id
         OR g.to_course_phase_id = cp.id
  )
`

func (q *Queries) GetNotOrderedCoursePhases(ctx context.Context, courseID uuid.UUID) ([]CoursePhase, error) {
	rows, err := q.db.Query(ctx, getNotOrderedCoursePhases, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoursePhase
	for rows.Next() {
		var i CoursePhase
		if err := rows.Scan(
			&i.ID,
			&i.CourseID,
			&i.Name,
			&i.MetaData,
			&i.IsInitialPhase,
			&i.CoursePhaseTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInitialCoursePhase = `-- name: UpdateInitialCoursePhase :exec
UPDATE course_phase
SET is_initial_phase = CASE 
    WHEN id = $2 THEN true
    ELSE false
END
WHERE course_id = $1
`

type UpdateInitialCoursePhaseParams struct {
	CourseID uuid.UUID `json:"course_id"`
	ID       uuid.UUID `json:"id"`
}

func (q *Queries) UpdateInitialCoursePhase(ctx context.Context, arg UpdateInitialCoursePhaseParams) error {
	_, err := q.db.Exec(ctx, updateInitialCoursePhase, arg.CourseID, arg.ID)
	return err
}
