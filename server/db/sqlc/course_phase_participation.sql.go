// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: course_phase_participation.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createCoursePhaseParticipation = `-- name: CreateCoursePhaseParticipation :one
INSERT INTO course_phase_participation (id, course_participation_id, course_phase_id, pass_status, meta_data)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, course_participation_id, course_phase_id, meta_data, pass_status, last_modified
`

type CreateCoursePhaseParticipationParams struct {
	ID                    uuid.UUID      `json:"id"`
	CourseParticipationID uuid.UUID      `json:"course_participation_id"`
	CoursePhaseID         uuid.UUID      `json:"course_phase_id"`
	PassStatus            NullPassStatus `json:"pass_status"`
	MetaData              []byte         `json:"meta_data"`
}

func (q *Queries) CreateCoursePhaseParticipation(ctx context.Context, arg CreateCoursePhaseParticipationParams) (CoursePhaseParticipation, error) {
	row := q.db.QueryRow(ctx, createCoursePhaseParticipation,
		arg.ID,
		arg.CourseParticipationID,
		arg.CoursePhaseID,
		arg.PassStatus,
		arg.MetaData,
	)
	var i CoursePhaseParticipation
	err := row.Scan(
		&i.ID,
		&i.CourseParticipationID,
		&i.CoursePhaseID,
		&i.MetaData,
		&i.PassStatus,
		&i.LastModified,
	)
	return i, err
}

const getAllCoursePhaseParticipationsForCourseParticipation = `-- name: GetAllCoursePhaseParticipationsForCourseParticipation :many
SELECT id, course_participation_id, course_phase_id, meta_data, pass_status, last_modified FROM course_phase_participation
WHERE course_participation_id = $1
`

func (q *Queries) GetAllCoursePhaseParticipationsForCourseParticipation(ctx context.Context, courseParticipationID uuid.UUID) ([]CoursePhaseParticipation, error) {
	rows, err := q.db.Query(ctx, getAllCoursePhaseParticipationsForCourseParticipation, courseParticipationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoursePhaseParticipation
	for rows.Next() {
		var i CoursePhaseParticipation
		if err := rows.Scan(
			&i.ID,
			&i.CourseParticipationID,
			&i.CoursePhaseID,
			&i.MetaData,
			&i.PassStatus,
			&i.LastModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCoursePhaseParticipationsForCoursePhase = `-- name: GetAllCoursePhaseParticipationsForCoursePhase :many
SELECT
    cpp.id AS course_phase_participation_id,
    cpp.pass_status,
    cpp.meta_data,
    s.id AS student_id,
    s.first_name,
    s.last_name,
    s.email,
    s.matriculation_number,
    s.university_login,
    s.has_university_account,
    s.gender
FROM
    course_phase_participation cpp
JOIN
    course_participation cp ON cpp.course_participation_id = cp.id
JOIN
    student s ON cp.student_id = s.id
WHERE
    cpp.course_phase_id = $1
`

type GetAllCoursePhaseParticipationsForCoursePhaseRow struct {
	CoursePhaseParticipationID uuid.UUID      `json:"course_phase_participation_id"`
	PassStatus                 NullPassStatus `json:"pass_status"`
	MetaData                   []byte         `json:"meta_data"`
	StudentID                  uuid.UUID      `json:"student_id"`
	FirstName                  pgtype.Text    `json:"first_name"`
	LastName                   pgtype.Text    `json:"last_name"`
	Email                      pgtype.Text    `json:"email"`
	MatriculationNumber        pgtype.Text    `json:"matriculation_number"`
	UniversityLogin            pgtype.Text    `json:"university_login"`
	HasUniversityAccount       pgtype.Bool    `json:"has_university_account"`
	Gender                     Gender         `json:"gender"`
}

func (q *Queries) GetAllCoursePhaseParticipationsForCoursePhase(ctx context.Context, coursePhaseID uuid.UUID) ([]GetAllCoursePhaseParticipationsForCoursePhaseRow, error) {
	rows, err := q.db.Query(ctx, getAllCoursePhaseParticipationsForCoursePhase, coursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCoursePhaseParticipationsForCoursePhaseRow
	for rows.Next() {
		var i GetAllCoursePhaseParticipationsForCoursePhaseRow
		if err := rows.Scan(
			&i.CoursePhaseParticipationID,
			&i.PassStatus,
			&i.MetaData,
			&i.StudentID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.MatriculationNumber,
			&i.UniversityLogin,
			&i.HasUniversityAccount,
			&i.Gender,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCoursePhaseParticipationsForCoursePhaseIncludingPrevious = `-- name: GetAllCoursePhaseParticipationsForCoursePhaseIncludingPrevious :many
WITH 
direct_predecessor_for_pass AS (
    SELECT cpg.from_course_phase_id AS phase_id
    FROM course_phase_graph cpg
    WHERE cpg.to_course_phase_id = $1
),

direct_predecessors_for_meta AS (
  SELECT 
    from_phase_id AS phase_id,
    cp.meta_data AS course_phase_meta_data,
    cp.course_phase_type_id AS course_phase_type_id
  FROM meta_data_dependency_graph
  JOIN course_phase cp
    ON cp.id = from_phase_id
  WHERE to_phase_id = $1
),

current_phase_participations AS (
    SELECT
        cpp.id                   AS course_phase_participation_id,
        cpp.pass_status          AS pass_status,
        cpp.meta_data            AS meta_data,
        s.id                     AS student_id,
        s.first_name,
        s.last_name,
        s.email,
        s.matriculation_number,
        s.university_login,
        s.has_university_account,
        s.gender,
        cp.id                    AS course_participation_id
    FROM course_phase_participation cpp
    JOIN course_participation cp 
      ON cpp.course_participation_id = cp.id
    JOIN student s 
      ON cp.student_id = s.id
    WHERE cpp.course_phase_id = $1
),

qualified_non_participants AS (
    SELECT
        NULL::uuid                   AS course_phase_participation_id,
        'not_assessed'::pass_status  AS pass_status,
        '{}'::jsonb                  AS meta_data,
        s.id                         AS student_id,
        s.first_name,
        s.last_name,
        s.email,
        s.matriculation_number,
        s.university_login,
        s.has_university_account,
        s.gender,
        cp.id                        AS course_participation_id
    FROM course_participation cp
    JOIN student s 
      ON cp.student_id = s.id

    WHERE 
      -- Exclude if they already have a participation in the current phase
      NOT EXISTS (
        SELECT 1
        FROM course_phase_participation new_cpp
        WHERE new_cpp.course_phase_id = $1
          AND new_cpp.course_participation_id = cp.id
      )
      
    -- And ensure they have 'passed' in the previous phase 
    -- We filter just previous, not all since phase order might change or allow for non-linear courses at some point
    AND EXISTS (
        SELECT 1
        FROM direct_predecessor_for_pass dpp
        JOIN  course_phase_participation pcpp
          ON pcpp.course_phase_id = dpp.phase_id
          AND pcpp.course_participation_id = cp.id
        WHERE (pcpp.pass_status = 'passed')
    )
)

SELECT
    main.course_phase_participation_id, main.pass_status, main.meta_data, main.student_id, main.first_name, main.last_name, main.email, main.matriculation_number, main.university_login, main.has_university_account, main.gender, main.course_participation_id,
    (COALESCE(
       (
          ----------------------------------------------------------------
          -- Getting non application meta data
          ----------------------------------------------------------------
          
          SELECT jsonb_object_agg(each.key, each.value)
          FROM direct_predecessors_for_meta dpm
          JOIN course_phase_participation pcpp
            ON pcpp.course_phase_id = dpm.phase_id
            AND pcpp.course_participation_id = main.course_participation_id
          JOIN course_phase_type cpt
            ON cpt.id = dpm.course_phase_type_id
            AND cpt.name != 'Application'
          CROSS JOIN LATERAL jsonb_each(pcpp.meta_data) each
            WHERE 
            -- Only keep meta_data where the JSON key matches one of the "name" attributes
                each.key IN (
                    SELECT elem->>'name'
                    FROM jsonb_array_elements(cpt.provided_output_meta_data) AS elem
                ) 
       ),
       '{}'
    )::jsonb ||
    COALESCE (
        (
          ----------------------------------------------------------------
          -- Getting meta data from the application phase (if it is a meta-data predecessor)
          -- We are expecting the following application meta data:
          -- {
          --   "exportAnswers": {
            --     "applicationScore": true,
            --     "additionalScores": [
            --       {  
            --         "key": "newName/Key",
            --         "name": "score1ToBeExported"
            --       }
            --     "answersText": [
            --       {
            --         "questionID": "uuid",
            --         "key": "string"
            --       }
            --     ],
            --     "answersMultiSelect": [
            --       {
            --         "questionID": "uuid",
            --         "key": "string"
            --       }
            --     ]
            --   }
          -- }
          ----------------------------------------------------------------
         SELECT appdata.obj
         FROM direct_predecessors_for_meta dpm
         JOIN course_phase_participation pcpp
           ON pcpp.course_phase_id = dpm.phase_id
          AND pcpp.course_participation_id = main.course_participation_id
         JOIN course_phase_type cpt
           ON cpt.id = dpm.course_phase_type_id
          AND cpt.name = 'Application'
          CROSS JOIN LATERAL (
             SELECT jsonb_build_object(
                     ----------------------------------------------------------
                     -- (A) Application Score
                     ----------------------------------------------------------
                     'applicationScore', (
                         SELECT to_jsonb(aasm.score)
                         FROM application_assessment aasm
                         WHERE aasm.course_phase_participation_id = pcpp.id
                           AND (dpm.course_phase_meta_data->'exportAnswers'->>'applicationScore') = 'true'
                     ),
                     ----------------------------------------------------------
                     -- (B) Additional Scores
                     ----------------------------------------------------------
                     'additionalScores', (
                         SELECT jsonb_agg(
                             jsonb_build_object(
                               'key', question_config->>'key',
                               'answer', pcpp.meta_data -> (question_config->>'key')
                             )
                         )
                         FROM jsonb_array_elements(
                                dpm.course_phase_meta_data->'additionalScores'
                              ) question_config
                     ),
                     ----------------------------------------------------------
                     -- (C) Aggregate Answers from text and multi-select questions
                     ----------------------------------------------------------
                     'applicationAnswers', (
                         SELECT jsonb_agg(answer_obj)
                         FROM (
                            -- Text answers
                            SELECT jsonb_build_object(
                                'key', qt.access_key,
                                'answer', to_jsonb(aat.answer),
                                'order_num', qt.order_num, 
                                'type', 'text'
                            ) AS answer_obj
                            FROM application_question_text qt
                            JOIN application_answer_text aat
                              ON aat.application_question_id = qt.id
                             AND aat.course_phase_participation_id = pcpp.id
                            WHERE qt.course_phase_id = dpm.phase_id
                              AND qt.accessible_for_other_phases = true
                              AND qt.access_key IS NOT NULL
                              AND qt.access_key <> ''
                            
                            UNION ALL
                            
                            -- Multi-select answers
                            SELECT jsonb_build_object(
                                'key', qm.access_key,
                                'answer', to_jsonb(aams.answer),
                                'order_num', qm.order_num, 
                                'type', 'multiselect'
                            ) AS answer_obj
                            FROM application_question_multi_select qm
                            JOIN application_answer_multi_select aams
                              ON aams.application_question_id = qm.id
                             AND aams.course_phase_participation_id = pcpp.id
                            WHERE qm.course_phase_id = dpm.phase_id
                              AND qm.accessible_for_other_phases = true
                              AND qm.access_key IS NOT NULL
                              AND qm.access_key <> ''
                         ) answer_union
                 )
             ) AS obj
         ) appdata
       ),
       '{}'
    )::jsonb)::jsonb AS prev_meta_data

FROM
(
    SELECT course_phase_participation_id, pass_status, meta_data, student_id, first_name, last_name, email, matriculation_number, university_login, has_university_account, gender, course_participation_id FROM current_phase_participations
    UNION
    SELECT course_phase_participation_id, pass_status, meta_data, student_id, first_name, last_name, email, matriculation_number, university_login, has_university_account, gender, course_participation_id FROM qualified_non_participants
) AS main
ORDER BY main.last_name, main.first_name
`

type GetAllCoursePhaseParticipationsForCoursePhaseIncludingPreviousRow struct {
	CoursePhaseParticipationID uuid.UUID      `json:"course_phase_participation_id"`
	PassStatus                 NullPassStatus `json:"pass_status"`
	MetaData                   []byte         `json:"meta_data"`
	StudentID                  uuid.UUID      `json:"student_id"`
	FirstName                  pgtype.Text    `json:"first_name"`
	LastName                   pgtype.Text    `json:"last_name"`
	Email                      pgtype.Text    `json:"email"`
	MatriculationNumber        pgtype.Text    `json:"matriculation_number"`
	UniversityLogin            pgtype.Text    `json:"university_login"`
	HasUniversityAccount       pgtype.Bool    `json:"has_university_account"`
	Gender                     Gender         `json:"gender"`
	CourseParticipationID      uuid.UUID      `json:"course_participation_id"`
	PrevMetaData               []byte         `json:"prev_meta_data"`
}

// ---------------------------------------------------------------------
// A) Phases a student must have 'passed' (per course_phase_graph)
// Identify the single previous phase (if any) required for PASS
// ---------------------------------------------------------------------
// ---------------------------------------------------------------------
// B) Phases from which we pull metadata (per meta_data_dependency_graph)
// ---------------------------------------------------------------------
// ---------------------------------------------------------------------
// 1) Existing participants in the current phase
// ---------------------------------------------------------------------
// ---------------------------------------------------------------------
// 2) Would-be participants:
//   - They do NOT yet have a course_phase_participation for $1
//   - Must have passed ALL direct_predecessors_for_pass
//
// ---------------------------------------------------------------------
// ---------------------------------------------------------------------
//  3. Final SELECT:
//     a) Combine existing + qualified participants
//     b) Merge all relevant meta_data from *all* direct_predecessors_for_meta
//
// ---------------------------------------------------------------------
func (q *Queries) GetAllCoursePhaseParticipationsForCoursePhaseIncludingPrevious(ctx context.Context, toCoursePhaseID uuid.UUID) ([]GetAllCoursePhaseParticipationsForCoursePhaseIncludingPreviousRow, error) {
	rows, err := q.db.Query(ctx, getAllCoursePhaseParticipationsForCoursePhaseIncludingPrevious, toCoursePhaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCoursePhaseParticipationsForCoursePhaseIncludingPreviousRow
	for rows.Next() {
		var i GetAllCoursePhaseParticipationsForCoursePhaseIncludingPreviousRow
		if err := rows.Scan(
			&i.CoursePhaseParticipationID,
			&i.PassStatus,
			&i.MetaData,
			&i.StudentID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.MatriculationNumber,
			&i.UniversityLogin,
			&i.HasUniversityAccount,
			&i.Gender,
			&i.CourseParticipationID,
			&i.PrevMetaData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoursePhaseParticipation = `-- name: GetCoursePhaseParticipation :one
SELECT id, course_participation_id, course_phase_id, meta_data, pass_status, last_modified FROM course_phase_participation
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCoursePhaseParticipation(ctx context.Context, id uuid.UUID) (CoursePhaseParticipation, error) {
	row := q.db.QueryRow(ctx, getCoursePhaseParticipation, id)
	var i CoursePhaseParticipation
	err := row.Scan(
		&i.ID,
		&i.CourseParticipationID,
		&i.CoursePhaseID,
		&i.MetaData,
		&i.PassStatus,
		&i.LastModified,
	)
	return i, err
}

const getCoursePhaseParticipationByCourseParticipationAndCoursePhase = `-- name: GetCoursePhaseParticipationByCourseParticipationAndCoursePhase :one
SELECT id, course_participation_id, course_phase_id, meta_data, pass_status, last_modified FROM course_phase_participation
WHERE course_participation_id = $1 AND course_phase_id = $2 LIMIT 1
`

type GetCoursePhaseParticipationByCourseParticipationAndCoursePhaseParams struct {
	CourseParticipationID uuid.UUID `json:"course_participation_id"`
	CoursePhaseID         uuid.UUID `json:"course_phase_id"`
}

func (q *Queries) GetCoursePhaseParticipationByCourseParticipationAndCoursePhase(ctx context.Context, arg GetCoursePhaseParticipationByCourseParticipationAndCoursePhaseParams) (CoursePhaseParticipation, error) {
	row := q.db.QueryRow(ctx, getCoursePhaseParticipationByCourseParticipationAndCoursePhase, arg.CourseParticipationID, arg.CoursePhaseID)
	var i CoursePhaseParticipation
	err := row.Scan(
		&i.ID,
		&i.CourseParticipationID,
		&i.CoursePhaseID,
		&i.MetaData,
		&i.PassStatus,
		&i.LastModified,
	)
	return i, err
}

const updateCoursePhaseParticipation = `-- name: UpdateCoursePhaseParticipation :exec
UPDATE course_phase_participation
SET 
    pass_status = COALESCE($2, pass_status),   
    meta_data = meta_data || $3
WHERE id = $1
`

type UpdateCoursePhaseParticipationParams struct {
	ID         uuid.UUID      `json:"id"`
	PassStatus NullPassStatus `json:"pass_status"`
	MetaData   []byte         `json:"meta_data"`
}

func (q *Queries) UpdateCoursePhaseParticipation(ctx context.Context, arg UpdateCoursePhaseParticipationParams) error {
	_, err := q.db.Exec(ctx, updateCoursePhaseParticipation, arg.ID, arg.PassStatus, arg.MetaData)
	return err
}

const updateCoursePhasePassStatus = `-- name: UpdateCoursePhasePassStatus :many
UPDATE course_phase_participation
SET pass_status = $3::pass_status
WHERE id = ANY($1::uuid[])
  AND course_phase_id = $2::uuid
  AND pass_status != $3::pass_status
RETURNING course_participation_id
`

type UpdateCoursePhasePassStatusParams struct {
	Column1 []uuid.UUID `json:"column_1"`
	Column2 uuid.UUID   `json:"column_2"`
	Column3 PassStatus  `json:"column_3"`
}

func (q *Queries) UpdateCoursePhasePassStatus(ctx context.Context, arg UpdateCoursePhasePassStatusParams) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, updateCoursePhasePassStatus, arg.Column1, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var course_participation_id uuid.UUID
		if err := rows.Scan(&course_participation_id); err != nil {
			return nil, err
		}
		items = append(items, course_participation_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
